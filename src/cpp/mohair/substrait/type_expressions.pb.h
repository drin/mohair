// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: substrait/type_expressions.proto
// Protobuf C++ Version: 4.25.0

#ifndef GOOGLE_PROTOBUF_INCLUDED_substrait_2ftype_5fexpressions_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_substrait_2ftype_5fexpressions_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025000 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "type.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_substrait_2ftype_5fexpressions_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_substrait_2ftype_5fexpressions_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_substrait_2ftype_5fexpressions_2eproto;
namespace substrait {
class DerivationExpression;
struct DerivationExpressionDefaultTypeInternal;
extern DerivationExpressionDefaultTypeInternal _DerivationExpression_default_instance_;
class DerivationExpression_BinaryOp;
struct DerivationExpression_BinaryOpDefaultTypeInternal;
extern DerivationExpression_BinaryOpDefaultTypeInternal _DerivationExpression_BinaryOp_default_instance_;
class DerivationExpression_ExpressionDecimal;
struct DerivationExpression_ExpressionDecimalDefaultTypeInternal;
extern DerivationExpression_ExpressionDecimalDefaultTypeInternal _DerivationExpression_ExpressionDecimal_default_instance_;
class DerivationExpression_ExpressionFixedBinary;
struct DerivationExpression_ExpressionFixedBinaryDefaultTypeInternal;
extern DerivationExpression_ExpressionFixedBinaryDefaultTypeInternal _DerivationExpression_ExpressionFixedBinary_default_instance_;
class DerivationExpression_ExpressionFixedChar;
struct DerivationExpression_ExpressionFixedCharDefaultTypeInternal;
extern DerivationExpression_ExpressionFixedCharDefaultTypeInternal _DerivationExpression_ExpressionFixedChar_default_instance_;
class DerivationExpression_ExpressionList;
struct DerivationExpression_ExpressionListDefaultTypeInternal;
extern DerivationExpression_ExpressionListDefaultTypeInternal _DerivationExpression_ExpressionList_default_instance_;
class DerivationExpression_ExpressionMap;
struct DerivationExpression_ExpressionMapDefaultTypeInternal;
extern DerivationExpression_ExpressionMapDefaultTypeInternal _DerivationExpression_ExpressionMap_default_instance_;
class DerivationExpression_ExpressionNamedStruct;
struct DerivationExpression_ExpressionNamedStructDefaultTypeInternal;
extern DerivationExpression_ExpressionNamedStructDefaultTypeInternal _DerivationExpression_ExpressionNamedStruct_default_instance_;
class DerivationExpression_ExpressionStruct;
struct DerivationExpression_ExpressionStructDefaultTypeInternal;
extern DerivationExpression_ExpressionStructDefaultTypeInternal _DerivationExpression_ExpressionStruct_default_instance_;
class DerivationExpression_ExpressionUserDefined;
struct DerivationExpression_ExpressionUserDefinedDefaultTypeInternal;
extern DerivationExpression_ExpressionUserDefinedDefaultTypeInternal _DerivationExpression_ExpressionUserDefined_default_instance_;
class DerivationExpression_ExpressionVarChar;
struct DerivationExpression_ExpressionVarCharDefaultTypeInternal;
extern DerivationExpression_ExpressionVarCharDefaultTypeInternal _DerivationExpression_ExpressionVarChar_default_instance_;
class DerivationExpression_IfElse;
struct DerivationExpression_IfElseDefaultTypeInternal;
extern DerivationExpression_IfElseDefaultTypeInternal _DerivationExpression_IfElse_default_instance_;
class DerivationExpression_ReturnProgram;
struct DerivationExpression_ReturnProgramDefaultTypeInternal;
extern DerivationExpression_ReturnProgramDefaultTypeInternal _DerivationExpression_ReturnProgram_default_instance_;
class DerivationExpression_ReturnProgram_Assignment;
struct DerivationExpression_ReturnProgram_AssignmentDefaultTypeInternal;
extern DerivationExpression_ReturnProgram_AssignmentDefaultTypeInternal _DerivationExpression_ReturnProgram_Assignment_default_instance_;
class DerivationExpression_UnaryOp;
struct DerivationExpression_UnaryOpDefaultTypeInternal;
extern DerivationExpression_UnaryOpDefaultTypeInternal _DerivationExpression_UnaryOp_default_instance_;
}  // namespace substrait
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace substrait {
enum DerivationExpression_UnaryOp_UnaryOpType : int {
  DerivationExpression_UnaryOp_UnaryOpType_UNARY_OP_TYPE_UNSPECIFIED = 0,
  DerivationExpression_UnaryOp_UnaryOpType_UNARY_OP_TYPE_BOOLEAN_NOT = 1,
  DerivationExpression_UnaryOp_UnaryOpType_DerivationExpression_UnaryOp_UnaryOpType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DerivationExpression_UnaryOp_UnaryOpType_DerivationExpression_UnaryOp_UnaryOpType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DerivationExpression_UnaryOp_UnaryOpType_IsValid(int value);
extern const uint32_t DerivationExpression_UnaryOp_UnaryOpType_internal_data_[];
constexpr DerivationExpression_UnaryOp_UnaryOpType DerivationExpression_UnaryOp_UnaryOpType_UnaryOpType_MIN = static_cast<DerivationExpression_UnaryOp_UnaryOpType>(0);
constexpr DerivationExpression_UnaryOp_UnaryOpType DerivationExpression_UnaryOp_UnaryOpType_UnaryOpType_MAX = static_cast<DerivationExpression_UnaryOp_UnaryOpType>(1);
constexpr int DerivationExpression_UnaryOp_UnaryOpType_UnaryOpType_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
DerivationExpression_UnaryOp_UnaryOpType_descriptor();
template <typename T>
const std::string& DerivationExpression_UnaryOp_UnaryOpType_Name(T value) {
  static_assert(std::is_same<T, DerivationExpression_UnaryOp_UnaryOpType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to UnaryOpType_Name().");
  return DerivationExpression_UnaryOp_UnaryOpType_Name(static_cast<DerivationExpression_UnaryOp_UnaryOpType>(value));
}
template <>
inline const std::string& DerivationExpression_UnaryOp_UnaryOpType_Name(DerivationExpression_UnaryOp_UnaryOpType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DerivationExpression_UnaryOp_UnaryOpType_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool DerivationExpression_UnaryOp_UnaryOpType_Parse(absl::string_view name, DerivationExpression_UnaryOp_UnaryOpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DerivationExpression_UnaryOp_UnaryOpType>(
      DerivationExpression_UnaryOp_UnaryOpType_descriptor(), name, value);
}
enum DerivationExpression_BinaryOp_BinaryOpType : int {
  DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_UNSPECIFIED = 0,
  DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_PLUS = 1,
  DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_MINUS = 2,
  DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_MULTIPLY = 3,
  DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_DIVIDE = 4,
  DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_MIN = 5,
  DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_MAX = 6,
  DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_GREATER_THAN = 7,
  DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_LESS_THAN = 8,
  DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_AND = 9,
  DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_OR = 10,
  DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_EQUALS = 11,
  DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_COVERS = 12,
  DerivationExpression_BinaryOp_BinaryOpType_DerivationExpression_BinaryOp_BinaryOpType_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  DerivationExpression_BinaryOp_BinaryOpType_DerivationExpression_BinaryOp_BinaryOpType_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool DerivationExpression_BinaryOp_BinaryOpType_IsValid(int value);
extern const uint32_t DerivationExpression_BinaryOp_BinaryOpType_internal_data_[];
constexpr DerivationExpression_BinaryOp_BinaryOpType DerivationExpression_BinaryOp_BinaryOpType_BinaryOpType_MIN = static_cast<DerivationExpression_BinaryOp_BinaryOpType>(0);
constexpr DerivationExpression_BinaryOp_BinaryOpType DerivationExpression_BinaryOp_BinaryOpType_BinaryOpType_MAX = static_cast<DerivationExpression_BinaryOp_BinaryOpType>(12);
constexpr int DerivationExpression_BinaryOp_BinaryOpType_BinaryOpType_ARRAYSIZE = 12 + 1;
const ::google::protobuf::EnumDescriptor*
DerivationExpression_BinaryOp_BinaryOpType_descriptor();
template <typename T>
const std::string& DerivationExpression_BinaryOp_BinaryOpType_Name(T value) {
  static_assert(std::is_same<T, DerivationExpression_BinaryOp_BinaryOpType>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to BinaryOpType_Name().");
  return DerivationExpression_BinaryOp_BinaryOpType_Name(static_cast<DerivationExpression_BinaryOp_BinaryOpType>(value));
}
template <>
inline const std::string& DerivationExpression_BinaryOp_BinaryOpType_Name(DerivationExpression_BinaryOp_BinaryOpType value) {
  return ::google::protobuf::internal::NameOfDenseEnum<DerivationExpression_BinaryOp_BinaryOpType_descriptor,
                                                 0, 12>(
      static_cast<int>(value));
}
inline bool DerivationExpression_BinaryOp_BinaryOpType_Parse(absl::string_view name, DerivationExpression_BinaryOp_BinaryOpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DerivationExpression_BinaryOp_BinaryOpType>(
      DerivationExpression_BinaryOp_BinaryOpType_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class DerivationExpression_ExpressionUserDefined final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.ExpressionUserDefined) */ {
 public:
  inline DerivationExpression_ExpressionUserDefined() : DerivationExpression_ExpressionUserDefined(nullptr) {}
  ~DerivationExpression_ExpressionUserDefined() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_ExpressionUserDefined(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_ExpressionUserDefined(const DerivationExpression_ExpressionUserDefined& from)
      : DerivationExpression_ExpressionUserDefined(nullptr, from) {}
  DerivationExpression_ExpressionUserDefined(DerivationExpression_ExpressionUserDefined&& from) noexcept
    : DerivationExpression_ExpressionUserDefined() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_ExpressionUserDefined& operator=(const DerivationExpression_ExpressionUserDefined& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_ExpressionUserDefined& operator=(DerivationExpression_ExpressionUserDefined&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_ExpressionUserDefined& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_ExpressionUserDefined* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_ExpressionUserDefined*>(
               &_DerivationExpression_ExpressionUserDefined_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DerivationExpression_ExpressionUserDefined& a, DerivationExpression_ExpressionUserDefined& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_ExpressionUserDefined* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_ExpressionUserDefined* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_ExpressionUserDefined* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_ExpressionUserDefined>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_ExpressionUserDefined& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_ExpressionUserDefined& from) {
    DerivationExpression_ExpressionUserDefined::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_ExpressionUserDefined* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.ExpressionUserDefined";
  }
  protected:
  explicit DerivationExpression_ExpressionUserDefined(::google::protobuf::Arena* arena);
  DerivationExpression_ExpressionUserDefined(::google::protobuf::Arena* arena, const DerivationExpression_ExpressionUserDefined& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypePointerFieldNumber = 1,
    kVariationPointerFieldNumber = 2,
    kNullabilityFieldNumber = 3,
  };
  // uint32 type_pointer = 1 [json_name = "typePointer"];
  void clear_type_pointer() ;
  ::uint32_t type_pointer() const;
  void set_type_pointer(::uint32_t value);

  private:
  ::uint32_t _internal_type_pointer() const;
  void _internal_set_type_pointer(::uint32_t value);

  public:
  // uint32 variation_pointer = 2 [json_name = "variationPointer"];
  void clear_variation_pointer() ;
  ::uint32_t variation_pointer() const;
  void set_variation_pointer(::uint32_t value);

  private:
  ::uint32_t _internal_variation_pointer() const;
  void _internal_set_variation_pointer(::uint32_t value);

  public:
  // .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
  void clear_nullability() ;
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);

  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.ExpressionUserDefined)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::uint32_t type_pointer_;
    ::uint32_t variation_pointer_;
    int nullability_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression) */ {
 public:
  inline DerivationExpression() : DerivationExpression(nullptr) {}
  ~DerivationExpression() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression(const DerivationExpression& from)
      : DerivationExpression(nullptr, from) {}
  DerivationExpression(DerivationExpression&& from) noexcept
    : DerivationExpression() {
    *this = ::std::move(from);
  }

  inline DerivationExpression& operator=(const DerivationExpression& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression& operator=(DerivationExpression&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kBool = 1,
    kI8 = 2,
    kI16 = 3,
    kI32 = 5,
    kI64 = 7,
    kFp32 = 10,
    kFp64 = 11,
    kString = 12,
    kBinary = 13,
    kTimestamp = 14,
    kDate = 16,
    kTime = 17,
    kIntervalYear = 19,
    kIntervalDay = 20,
    kTimestampTz = 29,
    kUuid = 32,
    kFixedChar = 21,
    kVarchar = 22,
    kFixedBinary = 23,
    kDecimal = 24,
    kStruct = 25,
    kList = 27,
    kMap = 28,
    kUserDefined = 30,
    kUserDefinedPointer = 31,
    kTypeParameterName = 33,
    kIntegerParameterName = 34,
    kIntegerLiteral = 35,
    kUnaryOp = 36,
    kBinaryOp = 37,
    kIfElse = 38,
    kReturnProgram = 39,
    KIND_NOT_SET = 0,
  };

  static inline const DerivationExpression* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression*>(
               &_DerivationExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DerivationExpression& a, DerivationExpression& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression& from) {
    DerivationExpression::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression";
  }
  protected:
  explicit DerivationExpression(::google::protobuf::Arena* arena);
  DerivationExpression(::google::protobuf::Arena* arena, const DerivationExpression& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using ExpressionFixedChar = DerivationExpression_ExpressionFixedChar;
  using ExpressionVarChar = DerivationExpression_ExpressionVarChar;
  using ExpressionFixedBinary = DerivationExpression_ExpressionFixedBinary;
  using ExpressionDecimal = DerivationExpression_ExpressionDecimal;
  using ExpressionStruct = DerivationExpression_ExpressionStruct;
  using ExpressionNamedStruct = DerivationExpression_ExpressionNamedStruct;
  using ExpressionList = DerivationExpression_ExpressionList;
  using ExpressionMap = DerivationExpression_ExpressionMap;
  using ExpressionUserDefined = DerivationExpression_ExpressionUserDefined;
  using IfElse = DerivationExpression_IfElse;
  using UnaryOp = DerivationExpression_UnaryOp;
  using BinaryOp = DerivationExpression_BinaryOp;
  using ReturnProgram = DerivationExpression_ReturnProgram;

  // accessors -------------------------------------------------------

  enum : int {
    kBoolFieldNumber = 1,
    kI8FieldNumber = 2,
    kI16FieldNumber = 3,
    kI32FieldNumber = 5,
    kI64FieldNumber = 7,
    kFp32FieldNumber = 10,
    kFp64FieldNumber = 11,
    kStringFieldNumber = 12,
    kBinaryFieldNumber = 13,
    kTimestampFieldNumber = 14,
    kDateFieldNumber = 16,
    kTimeFieldNumber = 17,
    kIntervalYearFieldNumber = 19,
    kIntervalDayFieldNumber = 20,
    kTimestampTzFieldNumber = 29,
    kUuidFieldNumber = 32,
    kFixedCharFieldNumber = 21,
    kVarcharFieldNumber = 22,
    kFixedBinaryFieldNumber = 23,
    kDecimalFieldNumber = 24,
    kStructFieldNumber = 25,
    kListFieldNumber = 27,
    kMapFieldNumber = 28,
    kUserDefinedFieldNumber = 30,
    kUserDefinedPointerFieldNumber = 31,
    kTypeParameterNameFieldNumber = 33,
    kIntegerParameterNameFieldNumber = 34,
    kIntegerLiteralFieldNumber = 35,
    kUnaryOpFieldNumber = 36,
    kBinaryOpFieldNumber = 37,
    kIfElseFieldNumber = 38,
    kReturnProgramFieldNumber = 39,
  };
  // .substrait.Type.Boolean bool = 1 [json_name = "bool"];
  bool has_bool_() const;
  private:
  bool _internal_has_bool_() const;

  public:
  void clear_bool_() ;
  const ::substrait::Type_Boolean& bool_() const;
  PROTOBUF_NODISCARD ::substrait::Type_Boolean* release_bool_();
  ::substrait::Type_Boolean* mutable_bool_();
  void set_allocated_bool_(::substrait::Type_Boolean* value);
  void unsafe_arena_set_allocated_bool_(::substrait::Type_Boolean* value);
  ::substrait::Type_Boolean* unsafe_arena_release_bool_();

  private:
  const ::substrait::Type_Boolean& _internal_bool_() const;
  ::substrait::Type_Boolean* _internal_mutable_bool_();

  public:
  // .substrait.Type.I8 i8 = 2 [json_name = "i8"];
  bool has_i8() const;
  private:
  bool _internal_has_i8() const;

  public:
  void clear_i8() ;
  const ::substrait::Type_I8& i8() const;
  PROTOBUF_NODISCARD ::substrait::Type_I8* release_i8();
  ::substrait::Type_I8* mutable_i8();
  void set_allocated_i8(::substrait::Type_I8* value);
  void unsafe_arena_set_allocated_i8(::substrait::Type_I8* value);
  ::substrait::Type_I8* unsafe_arena_release_i8();

  private:
  const ::substrait::Type_I8& _internal_i8() const;
  ::substrait::Type_I8* _internal_mutable_i8();

  public:
  // .substrait.Type.I16 i16 = 3 [json_name = "i16"];
  bool has_i16() const;
  private:
  bool _internal_has_i16() const;

  public:
  void clear_i16() ;
  const ::substrait::Type_I16& i16() const;
  PROTOBUF_NODISCARD ::substrait::Type_I16* release_i16();
  ::substrait::Type_I16* mutable_i16();
  void set_allocated_i16(::substrait::Type_I16* value);
  void unsafe_arena_set_allocated_i16(::substrait::Type_I16* value);
  ::substrait::Type_I16* unsafe_arena_release_i16();

  private:
  const ::substrait::Type_I16& _internal_i16() const;
  ::substrait::Type_I16* _internal_mutable_i16();

  public:
  // .substrait.Type.I32 i32 = 5 [json_name = "i32"];
  bool has_i32() const;
  private:
  bool _internal_has_i32() const;

  public:
  void clear_i32() ;
  const ::substrait::Type_I32& i32() const;
  PROTOBUF_NODISCARD ::substrait::Type_I32* release_i32();
  ::substrait::Type_I32* mutable_i32();
  void set_allocated_i32(::substrait::Type_I32* value);
  void unsafe_arena_set_allocated_i32(::substrait::Type_I32* value);
  ::substrait::Type_I32* unsafe_arena_release_i32();

  private:
  const ::substrait::Type_I32& _internal_i32() const;
  ::substrait::Type_I32* _internal_mutable_i32();

  public:
  // .substrait.Type.I64 i64 = 7 [json_name = "i64"];
  bool has_i64() const;
  private:
  bool _internal_has_i64() const;

  public:
  void clear_i64() ;
  const ::substrait::Type_I64& i64() const;
  PROTOBUF_NODISCARD ::substrait::Type_I64* release_i64();
  ::substrait::Type_I64* mutable_i64();
  void set_allocated_i64(::substrait::Type_I64* value);
  void unsafe_arena_set_allocated_i64(::substrait::Type_I64* value);
  ::substrait::Type_I64* unsafe_arena_release_i64();

  private:
  const ::substrait::Type_I64& _internal_i64() const;
  ::substrait::Type_I64* _internal_mutable_i64();

  public:
  // .substrait.Type.FP32 fp32 = 10 [json_name = "fp32"];
  bool has_fp32() const;
  private:
  bool _internal_has_fp32() const;

  public:
  void clear_fp32() ;
  const ::substrait::Type_FP32& fp32() const;
  PROTOBUF_NODISCARD ::substrait::Type_FP32* release_fp32();
  ::substrait::Type_FP32* mutable_fp32();
  void set_allocated_fp32(::substrait::Type_FP32* value);
  void unsafe_arena_set_allocated_fp32(::substrait::Type_FP32* value);
  ::substrait::Type_FP32* unsafe_arena_release_fp32();

  private:
  const ::substrait::Type_FP32& _internal_fp32() const;
  ::substrait::Type_FP32* _internal_mutable_fp32();

  public:
  // .substrait.Type.FP64 fp64 = 11 [json_name = "fp64"];
  bool has_fp64() const;
  private:
  bool _internal_has_fp64() const;

  public:
  void clear_fp64() ;
  const ::substrait::Type_FP64& fp64() const;
  PROTOBUF_NODISCARD ::substrait::Type_FP64* release_fp64();
  ::substrait::Type_FP64* mutable_fp64();
  void set_allocated_fp64(::substrait::Type_FP64* value);
  void unsafe_arena_set_allocated_fp64(::substrait::Type_FP64* value);
  ::substrait::Type_FP64* unsafe_arena_release_fp64();

  private:
  const ::substrait::Type_FP64& _internal_fp64() const;
  ::substrait::Type_FP64* _internal_mutable_fp64();

  public:
  // .substrait.Type.String string = 12 [json_name = "string"];
  bool has_string() const;
  private:
  bool _internal_has_string() const;

  public:
  void clear_string() ;
  const ::substrait::Type_String& string() const;
  PROTOBUF_NODISCARD ::substrait::Type_String* release_string();
  ::substrait::Type_String* mutable_string();
  void set_allocated_string(::substrait::Type_String* value);
  void unsafe_arena_set_allocated_string(::substrait::Type_String* value);
  ::substrait::Type_String* unsafe_arena_release_string();

  private:
  const ::substrait::Type_String& _internal_string() const;
  ::substrait::Type_String* _internal_mutable_string();

  public:
  // .substrait.Type.Binary binary = 13 [json_name = "binary"];
  bool has_binary() const;
  private:
  bool _internal_has_binary() const;

  public:
  void clear_binary() ;
  const ::substrait::Type_Binary& binary() const;
  PROTOBUF_NODISCARD ::substrait::Type_Binary* release_binary();
  ::substrait::Type_Binary* mutable_binary();
  void set_allocated_binary(::substrait::Type_Binary* value);
  void unsafe_arena_set_allocated_binary(::substrait::Type_Binary* value);
  ::substrait::Type_Binary* unsafe_arena_release_binary();

  private:
  const ::substrait::Type_Binary& _internal_binary() const;
  ::substrait::Type_Binary* _internal_mutable_binary();

  public:
  // .substrait.Type.Timestamp timestamp = 14 [json_name = "timestamp"];
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;

  public:
  void clear_timestamp() ;
  const ::substrait::Type_Timestamp& timestamp() const;
  PROTOBUF_NODISCARD ::substrait::Type_Timestamp* release_timestamp();
  ::substrait::Type_Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::substrait::Type_Timestamp* value);
  void unsafe_arena_set_allocated_timestamp(::substrait::Type_Timestamp* value);
  ::substrait::Type_Timestamp* unsafe_arena_release_timestamp();

  private:
  const ::substrait::Type_Timestamp& _internal_timestamp() const;
  ::substrait::Type_Timestamp* _internal_mutable_timestamp();

  public:
  // .substrait.Type.Date date = 16 [json_name = "date"];
  bool has_date() const;
  private:
  bool _internal_has_date() const;

  public:
  void clear_date() ;
  const ::substrait::Type_Date& date() const;
  PROTOBUF_NODISCARD ::substrait::Type_Date* release_date();
  ::substrait::Type_Date* mutable_date();
  void set_allocated_date(::substrait::Type_Date* value);
  void unsafe_arena_set_allocated_date(::substrait::Type_Date* value);
  ::substrait::Type_Date* unsafe_arena_release_date();

  private:
  const ::substrait::Type_Date& _internal_date() const;
  ::substrait::Type_Date* _internal_mutable_date();

  public:
  // .substrait.Type.Time time = 17 [json_name = "time"];
  bool has_time() const;
  private:
  bool _internal_has_time() const;

  public:
  void clear_time() ;
  const ::substrait::Type_Time& time() const;
  PROTOBUF_NODISCARD ::substrait::Type_Time* release_time();
  ::substrait::Type_Time* mutable_time();
  void set_allocated_time(::substrait::Type_Time* value);
  void unsafe_arena_set_allocated_time(::substrait::Type_Time* value);
  ::substrait::Type_Time* unsafe_arena_release_time();

  private:
  const ::substrait::Type_Time& _internal_time() const;
  ::substrait::Type_Time* _internal_mutable_time();

  public:
  // .substrait.Type.IntervalYear interval_year = 19 [json_name = "intervalYear"];
  bool has_interval_year() const;
  private:
  bool _internal_has_interval_year() const;

  public:
  void clear_interval_year() ;
  const ::substrait::Type_IntervalYear& interval_year() const;
  PROTOBUF_NODISCARD ::substrait::Type_IntervalYear* release_interval_year();
  ::substrait::Type_IntervalYear* mutable_interval_year();
  void set_allocated_interval_year(::substrait::Type_IntervalYear* value);
  void unsafe_arena_set_allocated_interval_year(::substrait::Type_IntervalYear* value);
  ::substrait::Type_IntervalYear* unsafe_arena_release_interval_year();

  private:
  const ::substrait::Type_IntervalYear& _internal_interval_year() const;
  ::substrait::Type_IntervalYear* _internal_mutable_interval_year();

  public:
  // .substrait.Type.IntervalDay interval_day = 20 [json_name = "intervalDay"];
  bool has_interval_day() const;
  private:
  bool _internal_has_interval_day() const;

  public:
  void clear_interval_day() ;
  const ::substrait::Type_IntervalDay& interval_day() const;
  PROTOBUF_NODISCARD ::substrait::Type_IntervalDay* release_interval_day();
  ::substrait::Type_IntervalDay* mutable_interval_day();
  void set_allocated_interval_day(::substrait::Type_IntervalDay* value);
  void unsafe_arena_set_allocated_interval_day(::substrait::Type_IntervalDay* value);
  ::substrait::Type_IntervalDay* unsafe_arena_release_interval_day();

  private:
  const ::substrait::Type_IntervalDay& _internal_interval_day() const;
  ::substrait::Type_IntervalDay* _internal_mutable_interval_day();

  public:
  // .substrait.Type.TimestampTZ timestamp_tz = 29 [json_name = "timestampTz"];
  bool has_timestamp_tz() const;
  private:
  bool _internal_has_timestamp_tz() const;

  public:
  void clear_timestamp_tz() ;
  const ::substrait::Type_TimestampTZ& timestamp_tz() const;
  PROTOBUF_NODISCARD ::substrait::Type_TimestampTZ* release_timestamp_tz();
  ::substrait::Type_TimestampTZ* mutable_timestamp_tz();
  void set_allocated_timestamp_tz(::substrait::Type_TimestampTZ* value);
  void unsafe_arena_set_allocated_timestamp_tz(::substrait::Type_TimestampTZ* value);
  ::substrait::Type_TimestampTZ* unsafe_arena_release_timestamp_tz();

  private:
  const ::substrait::Type_TimestampTZ& _internal_timestamp_tz() const;
  ::substrait::Type_TimestampTZ* _internal_mutable_timestamp_tz();

  public:
  // .substrait.Type.UUID uuid = 32 [json_name = "uuid"];
  bool has_uuid() const;
  private:
  bool _internal_has_uuid() const;

  public:
  void clear_uuid() ;
  const ::substrait::Type_UUID& uuid() const;
  PROTOBUF_NODISCARD ::substrait::Type_UUID* release_uuid();
  ::substrait::Type_UUID* mutable_uuid();
  void set_allocated_uuid(::substrait::Type_UUID* value);
  void unsafe_arena_set_allocated_uuid(::substrait::Type_UUID* value);
  ::substrait::Type_UUID* unsafe_arena_release_uuid();

  private:
  const ::substrait::Type_UUID& _internal_uuid() const;
  ::substrait::Type_UUID* _internal_mutable_uuid();

  public:
  // .substrait.DerivationExpression.ExpressionFixedChar fixed_char = 21 [json_name = "fixedChar"];
  bool has_fixed_char() const;
  private:
  bool _internal_has_fixed_char() const;

  public:
  void clear_fixed_char() ;
  const ::substrait::DerivationExpression_ExpressionFixedChar& fixed_char() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression_ExpressionFixedChar* release_fixed_char();
  ::substrait::DerivationExpression_ExpressionFixedChar* mutable_fixed_char();
  void set_allocated_fixed_char(::substrait::DerivationExpression_ExpressionFixedChar* value);
  void unsafe_arena_set_allocated_fixed_char(::substrait::DerivationExpression_ExpressionFixedChar* value);
  ::substrait::DerivationExpression_ExpressionFixedChar* unsafe_arena_release_fixed_char();

  private:
  const ::substrait::DerivationExpression_ExpressionFixedChar& _internal_fixed_char() const;
  ::substrait::DerivationExpression_ExpressionFixedChar* _internal_mutable_fixed_char();

  public:
  // .substrait.DerivationExpression.ExpressionVarChar varchar = 22 [json_name = "varchar"];
  bool has_varchar() const;
  private:
  bool _internal_has_varchar() const;

  public:
  void clear_varchar() ;
  const ::substrait::DerivationExpression_ExpressionVarChar& varchar() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression_ExpressionVarChar* release_varchar();
  ::substrait::DerivationExpression_ExpressionVarChar* mutable_varchar();
  void set_allocated_varchar(::substrait::DerivationExpression_ExpressionVarChar* value);
  void unsafe_arena_set_allocated_varchar(::substrait::DerivationExpression_ExpressionVarChar* value);
  ::substrait::DerivationExpression_ExpressionVarChar* unsafe_arena_release_varchar();

  private:
  const ::substrait::DerivationExpression_ExpressionVarChar& _internal_varchar() const;
  ::substrait::DerivationExpression_ExpressionVarChar* _internal_mutable_varchar();

  public:
  // .substrait.DerivationExpression.ExpressionFixedBinary fixed_binary = 23 [json_name = "fixedBinary"];
  bool has_fixed_binary() const;
  private:
  bool _internal_has_fixed_binary() const;

  public:
  void clear_fixed_binary() ;
  const ::substrait::DerivationExpression_ExpressionFixedBinary& fixed_binary() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression_ExpressionFixedBinary* release_fixed_binary();
  ::substrait::DerivationExpression_ExpressionFixedBinary* mutable_fixed_binary();
  void set_allocated_fixed_binary(::substrait::DerivationExpression_ExpressionFixedBinary* value);
  void unsafe_arena_set_allocated_fixed_binary(::substrait::DerivationExpression_ExpressionFixedBinary* value);
  ::substrait::DerivationExpression_ExpressionFixedBinary* unsafe_arena_release_fixed_binary();

  private:
  const ::substrait::DerivationExpression_ExpressionFixedBinary& _internal_fixed_binary() const;
  ::substrait::DerivationExpression_ExpressionFixedBinary* _internal_mutable_fixed_binary();

  public:
  // .substrait.DerivationExpression.ExpressionDecimal decimal = 24 [json_name = "decimal"];
  bool has_decimal() const;
  private:
  bool _internal_has_decimal() const;

  public:
  void clear_decimal() ;
  const ::substrait::DerivationExpression_ExpressionDecimal& decimal() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression_ExpressionDecimal* release_decimal();
  ::substrait::DerivationExpression_ExpressionDecimal* mutable_decimal();
  void set_allocated_decimal(::substrait::DerivationExpression_ExpressionDecimal* value);
  void unsafe_arena_set_allocated_decimal(::substrait::DerivationExpression_ExpressionDecimal* value);
  ::substrait::DerivationExpression_ExpressionDecimal* unsafe_arena_release_decimal();

  private:
  const ::substrait::DerivationExpression_ExpressionDecimal& _internal_decimal() const;
  ::substrait::DerivationExpression_ExpressionDecimal* _internal_mutable_decimal();

  public:
  // .substrait.DerivationExpression.ExpressionStruct struct = 25 [json_name = "struct"];
  bool has_struct_() const;
  private:
  bool _internal_has_struct_() const;

  public:
  void clear_struct_() ;
  const ::substrait::DerivationExpression_ExpressionStruct& struct_() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression_ExpressionStruct* release_struct_();
  ::substrait::DerivationExpression_ExpressionStruct* mutable_struct_();
  void set_allocated_struct_(::substrait::DerivationExpression_ExpressionStruct* value);
  void unsafe_arena_set_allocated_struct_(::substrait::DerivationExpression_ExpressionStruct* value);
  ::substrait::DerivationExpression_ExpressionStruct* unsafe_arena_release_struct_();

  private:
  const ::substrait::DerivationExpression_ExpressionStruct& _internal_struct_() const;
  ::substrait::DerivationExpression_ExpressionStruct* _internal_mutable_struct_();

  public:
  // .substrait.DerivationExpression.ExpressionList list = 27 [json_name = "list"];
  bool has_list() const;
  private:
  bool _internal_has_list() const;

  public:
  void clear_list() ;
  const ::substrait::DerivationExpression_ExpressionList& list() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression_ExpressionList* release_list();
  ::substrait::DerivationExpression_ExpressionList* mutable_list();
  void set_allocated_list(::substrait::DerivationExpression_ExpressionList* value);
  void unsafe_arena_set_allocated_list(::substrait::DerivationExpression_ExpressionList* value);
  ::substrait::DerivationExpression_ExpressionList* unsafe_arena_release_list();

  private:
  const ::substrait::DerivationExpression_ExpressionList& _internal_list() const;
  ::substrait::DerivationExpression_ExpressionList* _internal_mutable_list();

  public:
  // .substrait.DerivationExpression.ExpressionMap map = 28 [json_name = "map"];
  bool has_map() const;
  private:
  bool _internal_has_map() const;

  public:
  void clear_map() ;
  const ::substrait::DerivationExpression_ExpressionMap& map() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression_ExpressionMap* release_map();
  ::substrait::DerivationExpression_ExpressionMap* mutable_map();
  void set_allocated_map(::substrait::DerivationExpression_ExpressionMap* value);
  void unsafe_arena_set_allocated_map(::substrait::DerivationExpression_ExpressionMap* value);
  ::substrait::DerivationExpression_ExpressionMap* unsafe_arena_release_map();

  private:
  const ::substrait::DerivationExpression_ExpressionMap& _internal_map() const;
  ::substrait::DerivationExpression_ExpressionMap* _internal_mutable_map();

  public:
  // .substrait.DerivationExpression.ExpressionUserDefined user_defined = 30 [json_name = "userDefined"];
  bool has_user_defined() const;
  private:
  bool _internal_has_user_defined() const;

  public:
  void clear_user_defined() ;
  const ::substrait::DerivationExpression_ExpressionUserDefined& user_defined() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression_ExpressionUserDefined* release_user_defined();
  ::substrait::DerivationExpression_ExpressionUserDefined* mutable_user_defined();
  void set_allocated_user_defined(::substrait::DerivationExpression_ExpressionUserDefined* value);
  void unsafe_arena_set_allocated_user_defined(::substrait::DerivationExpression_ExpressionUserDefined* value);
  ::substrait::DerivationExpression_ExpressionUserDefined* unsafe_arena_release_user_defined();

  private:
  const ::substrait::DerivationExpression_ExpressionUserDefined& _internal_user_defined() const;
  ::substrait::DerivationExpression_ExpressionUserDefined* _internal_mutable_user_defined();

  public:
  // uint32 user_defined_pointer = 31 [json_name = "userDefinedPointer", deprecated = true];
  [[deprecated]]  bool has_user_defined_pointer() const;
  [[deprecated]]  void clear_user_defined_pointer() ;
  [[deprecated]] ::uint32_t user_defined_pointer() const;
  [[deprecated]] void set_user_defined_pointer(::uint32_t value);

  private:
  ::uint32_t _internal_user_defined_pointer() const;
  void _internal_set_user_defined_pointer(::uint32_t value);

  public:
  // string type_parameter_name = 33 [json_name = "typeParameterName"];
  bool has_type_parameter_name() const;
  void clear_type_parameter_name() ;
  const std::string& type_parameter_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_type_parameter_name(Arg_&& arg, Args_... args);
  std::string* mutable_type_parameter_name();
  PROTOBUF_NODISCARD std::string* release_type_parameter_name();
  void set_allocated_type_parameter_name(std::string* value);

  private:
  const std::string& _internal_type_parameter_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type_parameter_name(
      const std::string& value);
  std::string* _internal_mutable_type_parameter_name();

  public:
  // string integer_parameter_name = 34 [json_name = "integerParameterName"];
  bool has_integer_parameter_name() const;
  void clear_integer_parameter_name() ;
  const std::string& integer_parameter_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_integer_parameter_name(Arg_&& arg, Args_... args);
  std::string* mutable_integer_parameter_name();
  PROTOBUF_NODISCARD std::string* release_integer_parameter_name();
  void set_allocated_integer_parameter_name(std::string* value);

  private:
  const std::string& _internal_integer_parameter_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_integer_parameter_name(
      const std::string& value);
  std::string* _internal_mutable_integer_parameter_name();

  public:
  // int32 integer_literal = 35 [json_name = "integerLiteral"];
  bool has_integer_literal() const;
  void clear_integer_literal() ;
  ::int32_t integer_literal() const;
  void set_integer_literal(::int32_t value);

  private:
  ::int32_t _internal_integer_literal() const;
  void _internal_set_integer_literal(::int32_t value);

  public:
  // .substrait.DerivationExpression.UnaryOp unary_op = 36 [json_name = "unaryOp"];
  bool has_unary_op() const;
  private:
  bool _internal_has_unary_op() const;

  public:
  void clear_unary_op() ;
  const ::substrait::DerivationExpression_UnaryOp& unary_op() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression_UnaryOp* release_unary_op();
  ::substrait::DerivationExpression_UnaryOp* mutable_unary_op();
  void set_allocated_unary_op(::substrait::DerivationExpression_UnaryOp* value);
  void unsafe_arena_set_allocated_unary_op(::substrait::DerivationExpression_UnaryOp* value);
  ::substrait::DerivationExpression_UnaryOp* unsafe_arena_release_unary_op();

  private:
  const ::substrait::DerivationExpression_UnaryOp& _internal_unary_op() const;
  ::substrait::DerivationExpression_UnaryOp* _internal_mutable_unary_op();

  public:
  // .substrait.DerivationExpression.BinaryOp binary_op = 37 [json_name = "binaryOp"];
  bool has_binary_op() const;
  private:
  bool _internal_has_binary_op() const;

  public:
  void clear_binary_op() ;
  const ::substrait::DerivationExpression_BinaryOp& binary_op() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression_BinaryOp* release_binary_op();
  ::substrait::DerivationExpression_BinaryOp* mutable_binary_op();
  void set_allocated_binary_op(::substrait::DerivationExpression_BinaryOp* value);
  void unsafe_arena_set_allocated_binary_op(::substrait::DerivationExpression_BinaryOp* value);
  ::substrait::DerivationExpression_BinaryOp* unsafe_arena_release_binary_op();

  private:
  const ::substrait::DerivationExpression_BinaryOp& _internal_binary_op() const;
  ::substrait::DerivationExpression_BinaryOp* _internal_mutable_binary_op();

  public:
  // .substrait.DerivationExpression.IfElse if_else = 38 [json_name = "ifElse"];
  bool has_if_else() const;
  private:
  bool _internal_has_if_else() const;

  public:
  void clear_if_else() ;
  const ::substrait::DerivationExpression_IfElse& if_else() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression_IfElse* release_if_else();
  ::substrait::DerivationExpression_IfElse* mutable_if_else();
  void set_allocated_if_else(::substrait::DerivationExpression_IfElse* value);
  void unsafe_arena_set_allocated_if_else(::substrait::DerivationExpression_IfElse* value);
  ::substrait::DerivationExpression_IfElse* unsafe_arena_release_if_else();

  private:
  const ::substrait::DerivationExpression_IfElse& _internal_if_else() const;
  ::substrait::DerivationExpression_IfElse* _internal_mutable_if_else();

  public:
  // .substrait.DerivationExpression.ReturnProgram return_program = 39 [json_name = "returnProgram"];
  bool has_return_program() const;
  private:
  bool _internal_has_return_program() const;

  public:
  void clear_return_program() ;
  const ::substrait::DerivationExpression_ReturnProgram& return_program() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression_ReturnProgram* release_return_program();
  ::substrait::DerivationExpression_ReturnProgram* mutable_return_program();
  void set_allocated_return_program(::substrait::DerivationExpression_ReturnProgram* value);
  void unsafe_arena_set_allocated_return_program(::substrait::DerivationExpression_ReturnProgram* value);
  ::substrait::DerivationExpression_ReturnProgram* unsafe_arena_release_return_program();

  private:
  const ::substrait::DerivationExpression_ReturnProgram& _internal_return_program() const;
  ::substrait::DerivationExpression_ReturnProgram* _internal_mutable_return_program();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression)
 private:
  class _Internal;
  void set_has_bool_();
  void set_has_i8();
  void set_has_i16();
  void set_has_i32();
  void set_has_i64();
  void set_has_fp32();
  void set_has_fp64();
  void set_has_string();
  void set_has_binary();
  void set_has_timestamp();
  void set_has_date();
  void set_has_time();
  void set_has_interval_year();
  void set_has_interval_day();
  void set_has_timestamp_tz();
  void set_has_uuid();
  void set_has_fixed_char();
  void set_has_varchar();
  void set_has_fixed_binary();
  void set_has_decimal();
  void set_has_struct_();
  void set_has_list();
  void set_has_map();
  void set_has_user_defined();
  void set_has_user_defined_pointer();
  void set_has_type_parameter_name();
  void set_has_integer_parameter_name();
  void set_has_integer_literal();
  void set_has_unary_op();
  void set_has_binary_op();
  void set_has_if_else();
  void set_has_return_program();

  inline bool has_kind() const;
  inline void clear_has_kind();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 32, 28,
      112, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::substrait::Type_Boolean* bool__;
      ::substrait::Type_I8* i8_;
      ::substrait::Type_I16* i16_;
      ::substrait::Type_I32* i32_;
      ::substrait::Type_I64* i64_;
      ::substrait::Type_FP32* fp32_;
      ::substrait::Type_FP64* fp64_;
      ::substrait::Type_String* string_;
      ::substrait::Type_Binary* binary_;
      ::substrait::Type_Timestamp* timestamp_;
      ::substrait::Type_Date* date_;
      ::substrait::Type_Time* time_;
      ::substrait::Type_IntervalYear* interval_year_;
      ::substrait::Type_IntervalDay* interval_day_;
      ::substrait::Type_TimestampTZ* timestamp_tz_;
      ::substrait::Type_UUID* uuid_;
      ::substrait::DerivationExpression_ExpressionFixedChar* fixed_char_;
      ::substrait::DerivationExpression_ExpressionVarChar* varchar_;
      ::substrait::DerivationExpression_ExpressionFixedBinary* fixed_binary_;
      ::substrait::DerivationExpression_ExpressionDecimal* decimal_;
      ::substrait::DerivationExpression_ExpressionStruct* struct__;
      ::substrait::DerivationExpression_ExpressionList* list_;
      ::substrait::DerivationExpression_ExpressionMap* map_;
      ::substrait::DerivationExpression_ExpressionUserDefined* user_defined_;
      ::uint32_t user_defined_pointer_;
      ::google::protobuf::internal::ArenaStringPtr type_parameter_name_;
      ::google::protobuf::internal::ArenaStringPtr integer_parameter_name_;
      ::int32_t integer_literal_;
      ::substrait::DerivationExpression_UnaryOp* unary_op_;
      ::substrait::DerivationExpression_BinaryOp* binary_op_;
      ::substrait::DerivationExpression_IfElse* if_else_;
      ::substrait::DerivationExpression_ReturnProgram* return_program_;
    } kind_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression_BinaryOp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.BinaryOp) */ {
 public:
  inline DerivationExpression_BinaryOp() : DerivationExpression_BinaryOp(nullptr) {}
  ~DerivationExpression_BinaryOp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_BinaryOp(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_BinaryOp(const DerivationExpression_BinaryOp& from)
      : DerivationExpression_BinaryOp(nullptr, from) {}
  DerivationExpression_BinaryOp(DerivationExpression_BinaryOp&& from) noexcept
    : DerivationExpression_BinaryOp() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_BinaryOp& operator=(const DerivationExpression_BinaryOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_BinaryOp& operator=(DerivationExpression_BinaryOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_BinaryOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_BinaryOp* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_BinaryOp*>(
               &_DerivationExpression_BinaryOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DerivationExpression_BinaryOp& a, DerivationExpression_BinaryOp& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_BinaryOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_BinaryOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_BinaryOp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_BinaryOp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_BinaryOp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_BinaryOp& from) {
    DerivationExpression_BinaryOp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_BinaryOp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.BinaryOp";
  }
  protected:
  explicit DerivationExpression_BinaryOp(::google::protobuf::Arena* arena);
  DerivationExpression_BinaryOp(::google::protobuf::Arena* arena, const DerivationExpression_BinaryOp& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using BinaryOpType = DerivationExpression_BinaryOp_BinaryOpType;
  static constexpr BinaryOpType BINARY_OP_TYPE_UNSPECIFIED = DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_UNSPECIFIED;
  static constexpr BinaryOpType BINARY_OP_TYPE_PLUS = DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_PLUS;
  static constexpr BinaryOpType BINARY_OP_TYPE_MINUS = DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_MINUS;
  static constexpr BinaryOpType BINARY_OP_TYPE_MULTIPLY = DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_MULTIPLY;
  static constexpr BinaryOpType BINARY_OP_TYPE_DIVIDE = DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_DIVIDE;
  static constexpr BinaryOpType BINARY_OP_TYPE_MIN = DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_MIN;
  static constexpr BinaryOpType BINARY_OP_TYPE_MAX = DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_MAX;
  static constexpr BinaryOpType BINARY_OP_TYPE_GREATER_THAN = DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_GREATER_THAN;
  static constexpr BinaryOpType BINARY_OP_TYPE_LESS_THAN = DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_LESS_THAN;
  static constexpr BinaryOpType BINARY_OP_TYPE_AND = DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_AND;
  static constexpr BinaryOpType BINARY_OP_TYPE_OR = DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_OR;
  static constexpr BinaryOpType BINARY_OP_TYPE_EQUALS = DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_EQUALS;
  static constexpr BinaryOpType BINARY_OP_TYPE_COVERS = DerivationExpression_BinaryOp_BinaryOpType_BINARY_OP_TYPE_COVERS;
  static inline bool BinaryOpType_IsValid(int value) {
    return DerivationExpression_BinaryOp_BinaryOpType_IsValid(value);
  }
  static constexpr BinaryOpType BinaryOpType_MIN = DerivationExpression_BinaryOp_BinaryOpType_BinaryOpType_MIN;
  static constexpr BinaryOpType BinaryOpType_MAX = DerivationExpression_BinaryOp_BinaryOpType_BinaryOpType_MAX;
  static constexpr int BinaryOpType_ARRAYSIZE = DerivationExpression_BinaryOp_BinaryOpType_BinaryOpType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* BinaryOpType_descriptor() {
    return DerivationExpression_BinaryOp_BinaryOpType_descriptor();
  }
  template <typename T>
  static inline const std::string& BinaryOpType_Name(T value) {
    return DerivationExpression_BinaryOp_BinaryOpType_Name(value);
  }
  static inline bool BinaryOpType_Parse(absl::string_view name, BinaryOpType* value) {
    return DerivationExpression_BinaryOp_BinaryOpType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kArg1FieldNumber = 2,
    kArg2FieldNumber = 3,
    kOpTypeFieldNumber = 1,
  };
  // .substrait.DerivationExpression arg1 = 2 [json_name = "arg1"];
  bool has_arg1() const;
  void clear_arg1() ;
  const ::substrait::DerivationExpression& arg1() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_arg1();
  ::substrait::DerivationExpression* mutable_arg1();
  void set_allocated_arg1(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_arg1(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_arg1();

  private:
  const ::substrait::DerivationExpression& _internal_arg1() const;
  ::substrait::DerivationExpression* _internal_mutable_arg1();

  public:
  // .substrait.DerivationExpression arg2 = 3 [json_name = "arg2"];
  bool has_arg2() const;
  void clear_arg2() ;
  const ::substrait::DerivationExpression& arg2() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_arg2();
  ::substrait::DerivationExpression* mutable_arg2();
  void set_allocated_arg2(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_arg2(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_arg2();

  private:
  const ::substrait::DerivationExpression& _internal_arg2() const;
  ::substrait::DerivationExpression* _internal_mutable_arg2();

  public:
  // .substrait.DerivationExpression.BinaryOp.BinaryOpType op_type = 1 [json_name = "opType"];
  void clear_op_type() ;
  ::substrait::DerivationExpression_BinaryOp_BinaryOpType op_type() const;
  void set_op_type(::substrait::DerivationExpression_BinaryOp_BinaryOpType value);

  private:
  ::substrait::DerivationExpression_BinaryOp_BinaryOpType _internal_op_type() const;
  void _internal_set_op_type(::substrait::DerivationExpression_BinaryOp_BinaryOpType value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.BinaryOp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::DerivationExpression* arg1_;
    ::substrait::DerivationExpression* arg2_;
    int op_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression_ExpressionDecimal final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.ExpressionDecimal) */ {
 public:
  inline DerivationExpression_ExpressionDecimal() : DerivationExpression_ExpressionDecimal(nullptr) {}
  ~DerivationExpression_ExpressionDecimal() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_ExpressionDecimal(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_ExpressionDecimal(const DerivationExpression_ExpressionDecimal& from)
      : DerivationExpression_ExpressionDecimal(nullptr, from) {}
  DerivationExpression_ExpressionDecimal(DerivationExpression_ExpressionDecimal&& from) noexcept
    : DerivationExpression_ExpressionDecimal() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_ExpressionDecimal& operator=(const DerivationExpression_ExpressionDecimal& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_ExpressionDecimal& operator=(DerivationExpression_ExpressionDecimal&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_ExpressionDecimal& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_ExpressionDecimal* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_ExpressionDecimal*>(
               &_DerivationExpression_ExpressionDecimal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DerivationExpression_ExpressionDecimal& a, DerivationExpression_ExpressionDecimal& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_ExpressionDecimal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_ExpressionDecimal* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_ExpressionDecimal* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_ExpressionDecimal>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_ExpressionDecimal& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_ExpressionDecimal& from) {
    DerivationExpression_ExpressionDecimal::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_ExpressionDecimal* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.ExpressionDecimal";
  }
  protected:
  explicit DerivationExpression_ExpressionDecimal(::google::protobuf::Arena* arena);
  DerivationExpression_ExpressionDecimal(::google::protobuf::Arena* arena, const DerivationExpression_ExpressionDecimal& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScaleFieldNumber = 1,
    kPrecisionFieldNumber = 2,
    kVariationPointerFieldNumber = 3,
    kNullabilityFieldNumber = 4,
  };
  // .substrait.DerivationExpression scale = 1 [json_name = "scale"];
  bool has_scale() const;
  void clear_scale() ;
  const ::substrait::DerivationExpression& scale() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_scale();
  ::substrait::DerivationExpression* mutable_scale();
  void set_allocated_scale(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_scale(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_scale();

  private:
  const ::substrait::DerivationExpression& _internal_scale() const;
  ::substrait::DerivationExpression* _internal_mutable_scale();

  public:
  // .substrait.DerivationExpression precision = 2 [json_name = "precision"];
  bool has_precision() const;
  void clear_precision() ;
  const ::substrait::DerivationExpression& precision() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_precision();
  ::substrait::DerivationExpression* mutable_precision();
  void set_allocated_precision(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_precision(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_precision();

  private:
  const ::substrait::DerivationExpression& _internal_precision() const;
  ::substrait::DerivationExpression* _internal_mutable_precision();

  public:
  // uint32 variation_pointer = 3 [json_name = "variationPointer"];
  void clear_variation_pointer() ;
  ::uint32_t variation_pointer() const;
  void set_variation_pointer(::uint32_t value);

  private:
  ::uint32_t _internal_variation_pointer() const;
  void _internal_set_variation_pointer(::uint32_t value);

  public:
  // .substrait.Type.Nullability nullability = 4 [json_name = "nullability"];
  void clear_nullability() ;
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);

  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.ExpressionDecimal)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::DerivationExpression* scale_;
    ::substrait::DerivationExpression* precision_;
    ::uint32_t variation_pointer_;
    int nullability_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression_ExpressionFixedBinary final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.ExpressionFixedBinary) */ {
 public:
  inline DerivationExpression_ExpressionFixedBinary() : DerivationExpression_ExpressionFixedBinary(nullptr) {}
  ~DerivationExpression_ExpressionFixedBinary() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_ExpressionFixedBinary(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_ExpressionFixedBinary(const DerivationExpression_ExpressionFixedBinary& from)
      : DerivationExpression_ExpressionFixedBinary(nullptr, from) {}
  DerivationExpression_ExpressionFixedBinary(DerivationExpression_ExpressionFixedBinary&& from) noexcept
    : DerivationExpression_ExpressionFixedBinary() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_ExpressionFixedBinary& operator=(const DerivationExpression_ExpressionFixedBinary& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_ExpressionFixedBinary& operator=(DerivationExpression_ExpressionFixedBinary&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_ExpressionFixedBinary& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_ExpressionFixedBinary* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_ExpressionFixedBinary*>(
               &_DerivationExpression_ExpressionFixedBinary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DerivationExpression_ExpressionFixedBinary& a, DerivationExpression_ExpressionFixedBinary& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_ExpressionFixedBinary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_ExpressionFixedBinary* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_ExpressionFixedBinary* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_ExpressionFixedBinary>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_ExpressionFixedBinary& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_ExpressionFixedBinary& from) {
    DerivationExpression_ExpressionFixedBinary::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_ExpressionFixedBinary* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.ExpressionFixedBinary";
  }
  protected:
  explicit DerivationExpression_ExpressionFixedBinary(::google::protobuf::Arena* arena);
  DerivationExpression_ExpressionFixedBinary(::google::protobuf::Arena* arena, const DerivationExpression_ExpressionFixedBinary& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthFieldNumber = 1,
    kVariationPointerFieldNumber = 2,
    kNullabilityFieldNumber = 3,
  };
  // .substrait.DerivationExpression length = 1 [json_name = "length"];
  bool has_length() const;
  void clear_length() ;
  const ::substrait::DerivationExpression& length() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_length();
  ::substrait::DerivationExpression* mutable_length();
  void set_allocated_length(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_length(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_length();

  private:
  const ::substrait::DerivationExpression& _internal_length() const;
  ::substrait::DerivationExpression* _internal_mutable_length();

  public:
  // uint32 variation_pointer = 2 [json_name = "variationPointer"];
  void clear_variation_pointer() ;
  ::uint32_t variation_pointer() const;
  void set_variation_pointer(::uint32_t value);

  private:
  ::uint32_t _internal_variation_pointer() const;
  void _internal_set_variation_pointer(::uint32_t value);

  public:
  // .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
  void clear_nullability() ;
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);

  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.ExpressionFixedBinary)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::DerivationExpression* length_;
    ::uint32_t variation_pointer_;
    int nullability_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression_ExpressionFixedChar final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.ExpressionFixedChar) */ {
 public:
  inline DerivationExpression_ExpressionFixedChar() : DerivationExpression_ExpressionFixedChar(nullptr) {}
  ~DerivationExpression_ExpressionFixedChar() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_ExpressionFixedChar(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_ExpressionFixedChar(const DerivationExpression_ExpressionFixedChar& from)
      : DerivationExpression_ExpressionFixedChar(nullptr, from) {}
  DerivationExpression_ExpressionFixedChar(DerivationExpression_ExpressionFixedChar&& from) noexcept
    : DerivationExpression_ExpressionFixedChar() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_ExpressionFixedChar& operator=(const DerivationExpression_ExpressionFixedChar& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_ExpressionFixedChar& operator=(DerivationExpression_ExpressionFixedChar&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_ExpressionFixedChar& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_ExpressionFixedChar* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_ExpressionFixedChar*>(
               &_DerivationExpression_ExpressionFixedChar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DerivationExpression_ExpressionFixedChar& a, DerivationExpression_ExpressionFixedChar& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_ExpressionFixedChar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_ExpressionFixedChar* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_ExpressionFixedChar* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_ExpressionFixedChar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_ExpressionFixedChar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_ExpressionFixedChar& from) {
    DerivationExpression_ExpressionFixedChar::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_ExpressionFixedChar* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.ExpressionFixedChar";
  }
  protected:
  explicit DerivationExpression_ExpressionFixedChar(::google::protobuf::Arena* arena);
  DerivationExpression_ExpressionFixedChar(::google::protobuf::Arena* arena, const DerivationExpression_ExpressionFixedChar& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthFieldNumber = 1,
    kVariationPointerFieldNumber = 2,
    kNullabilityFieldNumber = 3,
  };
  // .substrait.DerivationExpression length = 1 [json_name = "length"];
  bool has_length() const;
  void clear_length() ;
  const ::substrait::DerivationExpression& length() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_length();
  ::substrait::DerivationExpression* mutable_length();
  void set_allocated_length(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_length(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_length();

  private:
  const ::substrait::DerivationExpression& _internal_length() const;
  ::substrait::DerivationExpression* _internal_mutable_length();

  public:
  // uint32 variation_pointer = 2 [json_name = "variationPointer"];
  void clear_variation_pointer() ;
  ::uint32_t variation_pointer() const;
  void set_variation_pointer(::uint32_t value);

  private:
  ::uint32_t _internal_variation_pointer() const;
  void _internal_set_variation_pointer(::uint32_t value);

  public:
  // .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
  void clear_nullability() ;
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);

  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.ExpressionFixedChar)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::DerivationExpression* length_;
    ::uint32_t variation_pointer_;
    int nullability_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression_ExpressionList final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.ExpressionList) */ {
 public:
  inline DerivationExpression_ExpressionList() : DerivationExpression_ExpressionList(nullptr) {}
  ~DerivationExpression_ExpressionList() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_ExpressionList(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_ExpressionList(const DerivationExpression_ExpressionList& from)
      : DerivationExpression_ExpressionList(nullptr, from) {}
  DerivationExpression_ExpressionList(DerivationExpression_ExpressionList&& from) noexcept
    : DerivationExpression_ExpressionList() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_ExpressionList& operator=(const DerivationExpression_ExpressionList& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_ExpressionList& operator=(DerivationExpression_ExpressionList&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_ExpressionList& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_ExpressionList* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_ExpressionList*>(
               &_DerivationExpression_ExpressionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DerivationExpression_ExpressionList& a, DerivationExpression_ExpressionList& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_ExpressionList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_ExpressionList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_ExpressionList* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_ExpressionList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_ExpressionList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_ExpressionList& from) {
    DerivationExpression_ExpressionList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_ExpressionList* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.ExpressionList";
  }
  protected:
  explicit DerivationExpression_ExpressionList(::google::protobuf::Arena* arena);
  DerivationExpression_ExpressionList(::google::protobuf::Arena* arena, const DerivationExpression_ExpressionList& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kVariationPointerFieldNumber = 2,
    kNullabilityFieldNumber = 3,
  };
  // .substrait.DerivationExpression type = 1 [json_name = "type"];
  bool has_type() const;
  void clear_type() ;
  const ::substrait::DerivationExpression& type() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_type();
  ::substrait::DerivationExpression* mutable_type();
  void set_allocated_type(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_type(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_type();

  private:
  const ::substrait::DerivationExpression& _internal_type() const;
  ::substrait::DerivationExpression* _internal_mutable_type();

  public:
  // uint32 variation_pointer = 2 [json_name = "variationPointer"];
  void clear_variation_pointer() ;
  ::uint32_t variation_pointer() const;
  void set_variation_pointer(::uint32_t value);

  private:
  ::uint32_t _internal_variation_pointer() const;
  void _internal_set_variation_pointer(::uint32_t value);

  public:
  // .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
  void clear_nullability() ;
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);

  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.ExpressionList)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::DerivationExpression* type_;
    ::uint32_t variation_pointer_;
    int nullability_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression_ExpressionMap final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.ExpressionMap) */ {
 public:
  inline DerivationExpression_ExpressionMap() : DerivationExpression_ExpressionMap(nullptr) {}
  ~DerivationExpression_ExpressionMap() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_ExpressionMap(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_ExpressionMap(const DerivationExpression_ExpressionMap& from)
      : DerivationExpression_ExpressionMap(nullptr, from) {}
  DerivationExpression_ExpressionMap(DerivationExpression_ExpressionMap&& from) noexcept
    : DerivationExpression_ExpressionMap() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_ExpressionMap& operator=(const DerivationExpression_ExpressionMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_ExpressionMap& operator=(DerivationExpression_ExpressionMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_ExpressionMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_ExpressionMap* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_ExpressionMap*>(
               &_DerivationExpression_ExpressionMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DerivationExpression_ExpressionMap& a, DerivationExpression_ExpressionMap& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_ExpressionMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_ExpressionMap* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_ExpressionMap* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_ExpressionMap>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_ExpressionMap& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_ExpressionMap& from) {
    DerivationExpression_ExpressionMap::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_ExpressionMap* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.ExpressionMap";
  }
  protected:
  explicit DerivationExpression_ExpressionMap(::google::protobuf::Arena* arena);
  DerivationExpression_ExpressionMap(::google::protobuf::Arena* arena, const DerivationExpression_ExpressionMap& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
    kVariationPointerFieldNumber = 3,
    kNullabilityFieldNumber = 4,
  };
  // .substrait.DerivationExpression key = 1 [json_name = "key"];
  bool has_key() const;
  void clear_key() ;
  const ::substrait::DerivationExpression& key() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_key();
  ::substrait::DerivationExpression* mutable_key();
  void set_allocated_key(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_key(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_key();

  private:
  const ::substrait::DerivationExpression& _internal_key() const;
  ::substrait::DerivationExpression* _internal_mutable_key();

  public:
  // .substrait.DerivationExpression value = 2 [json_name = "value"];
  bool has_value() const;
  void clear_value() ;
  const ::substrait::DerivationExpression& value() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_value();
  ::substrait::DerivationExpression* mutable_value();
  void set_allocated_value(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_value(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_value();

  private:
  const ::substrait::DerivationExpression& _internal_value() const;
  ::substrait::DerivationExpression* _internal_mutable_value();

  public:
  // uint32 variation_pointer = 3 [json_name = "variationPointer"];
  void clear_variation_pointer() ;
  ::uint32_t variation_pointer() const;
  void set_variation_pointer(::uint32_t value);

  private:
  ::uint32_t _internal_variation_pointer() const;
  void _internal_set_variation_pointer(::uint32_t value);

  public:
  // .substrait.Type.Nullability nullability = 4 [json_name = "nullability"];
  void clear_nullability() ;
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);

  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.ExpressionMap)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::DerivationExpression* key_;
    ::substrait::DerivationExpression* value_;
    ::uint32_t variation_pointer_;
    int nullability_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression_ExpressionStruct final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.ExpressionStruct) */ {
 public:
  inline DerivationExpression_ExpressionStruct() : DerivationExpression_ExpressionStruct(nullptr) {}
  ~DerivationExpression_ExpressionStruct() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_ExpressionStruct(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_ExpressionStruct(const DerivationExpression_ExpressionStruct& from)
      : DerivationExpression_ExpressionStruct(nullptr, from) {}
  DerivationExpression_ExpressionStruct(DerivationExpression_ExpressionStruct&& from) noexcept
    : DerivationExpression_ExpressionStruct() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_ExpressionStruct& operator=(const DerivationExpression_ExpressionStruct& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_ExpressionStruct& operator=(DerivationExpression_ExpressionStruct&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_ExpressionStruct& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_ExpressionStruct* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_ExpressionStruct*>(
               &_DerivationExpression_ExpressionStruct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DerivationExpression_ExpressionStruct& a, DerivationExpression_ExpressionStruct& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_ExpressionStruct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_ExpressionStruct* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_ExpressionStruct* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_ExpressionStruct>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_ExpressionStruct& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_ExpressionStruct& from) {
    DerivationExpression_ExpressionStruct::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_ExpressionStruct* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.ExpressionStruct";
  }
  protected:
  explicit DerivationExpression_ExpressionStruct(::google::protobuf::Arena* arena);
  DerivationExpression_ExpressionStruct(::google::protobuf::Arena* arena, const DerivationExpression_ExpressionStruct& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypesFieldNumber = 1,
    kVariationPointerFieldNumber = 2,
    kNullabilityFieldNumber = 3,
  };
  // repeated .substrait.DerivationExpression types = 1 [json_name = "types"];
  int types_size() const;
  private:
  int _internal_types_size() const;

  public:
  void clear_types() ;
  ::substrait::DerivationExpression* mutable_types(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::DerivationExpression >*
      mutable_types();
  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::DerivationExpression>& _internal_types() const;
  ::google::protobuf::RepeatedPtrField<::substrait::DerivationExpression>* _internal_mutable_types();
  public:
  const ::substrait::DerivationExpression& types(int index) const;
  ::substrait::DerivationExpression* add_types();
  const ::google::protobuf::RepeatedPtrField< ::substrait::DerivationExpression >&
      types() const;
  // uint32 variation_pointer = 2 [json_name = "variationPointer"];
  void clear_variation_pointer() ;
  ::uint32_t variation_pointer() const;
  void set_variation_pointer(::uint32_t value);

  private:
  ::uint32_t _internal_variation_pointer() const;
  void _internal_set_variation_pointer(::uint32_t value);

  public:
  // .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
  void clear_nullability() ;
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);

  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.ExpressionStruct)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::substrait::DerivationExpression > types_;
    ::uint32_t variation_pointer_;
    int nullability_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression_ExpressionVarChar final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.ExpressionVarChar) */ {
 public:
  inline DerivationExpression_ExpressionVarChar() : DerivationExpression_ExpressionVarChar(nullptr) {}
  ~DerivationExpression_ExpressionVarChar() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_ExpressionVarChar(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_ExpressionVarChar(const DerivationExpression_ExpressionVarChar& from)
      : DerivationExpression_ExpressionVarChar(nullptr, from) {}
  DerivationExpression_ExpressionVarChar(DerivationExpression_ExpressionVarChar&& from) noexcept
    : DerivationExpression_ExpressionVarChar() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_ExpressionVarChar& operator=(const DerivationExpression_ExpressionVarChar& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_ExpressionVarChar& operator=(DerivationExpression_ExpressionVarChar&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_ExpressionVarChar& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_ExpressionVarChar* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_ExpressionVarChar*>(
               &_DerivationExpression_ExpressionVarChar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DerivationExpression_ExpressionVarChar& a, DerivationExpression_ExpressionVarChar& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_ExpressionVarChar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_ExpressionVarChar* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_ExpressionVarChar* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_ExpressionVarChar>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_ExpressionVarChar& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_ExpressionVarChar& from) {
    DerivationExpression_ExpressionVarChar::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_ExpressionVarChar* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.ExpressionVarChar";
  }
  protected:
  explicit DerivationExpression_ExpressionVarChar(::google::protobuf::Arena* arena);
  DerivationExpression_ExpressionVarChar(::google::protobuf::Arena* arena, const DerivationExpression_ExpressionVarChar& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLengthFieldNumber = 1,
    kVariationPointerFieldNumber = 2,
    kNullabilityFieldNumber = 3,
  };
  // .substrait.DerivationExpression length = 1 [json_name = "length"];
  bool has_length() const;
  void clear_length() ;
  const ::substrait::DerivationExpression& length() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_length();
  ::substrait::DerivationExpression* mutable_length();
  void set_allocated_length(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_length(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_length();

  private:
  const ::substrait::DerivationExpression& _internal_length() const;
  ::substrait::DerivationExpression* _internal_mutable_length();

  public:
  // uint32 variation_pointer = 2 [json_name = "variationPointer"];
  void clear_variation_pointer() ;
  ::uint32_t variation_pointer() const;
  void set_variation_pointer(::uint32_t value);

  private:
  ::uint32_t _internal_variation_pointer() const;
  void _internal_set_variation_pointer(::uint32_t value);

  public:
  // .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
  void clear_nullability() ;
  ::substrait::Type_Nullability nullability() const;
  void set_nullability(::substrait::Type_Nullability value);

  private:
  ::substrait::Type_Nullability _internal_nullability() const;
  void _internal_set_nullability(::substrait::Type_Nullability value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.ExpressionVarChar)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::DerivationExpression* length_;
    ::uint32_t variation_pointer_;
    int nullability_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression_IfElse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.IfElse) */ {
 public:
  inline DerivationExpression_IfElse() : DerivationExpression_IfElse(nullptr) {}
  ~DerivationExpression_IfElse() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_IfElse(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_IfElse(const DerivationExpression_IfElse& from)
      : DerivationExpression_IfElse(nullptr, from) {}
  DerivationExpression_IfElse(DerivationExpression_IfElse&& from) noexcept
    : DerivationExpression_IfElse() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_IfElse& operator=(const DerivationExpression_IfElse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_IfElse& operator=(DerivationExpression_IfElse&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_IfElse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_IfElse* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_IfElse*>(
               &_DerivationExpression_IfElse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DerivationExpression_IfElse& a, DerivationExpression_IfElse& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_IfElse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_IfElse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_IfElse* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_IfElse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_IfElse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_IfElse& from) {
    DerivationExpression_IfElse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_IfElse* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.IfElse";
  }
  protected:
  explicit DerivationExpression_IfElse(::google::protobuf::Arena* arena);
  DerivationExpression_IfElse(::google::protobuf::Arena* arena, const DerivationExpression_IfElse& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIfConditionFieldNumber = 1,
    kIfReturnFieldNumber = 2,
    kElseReturnFieldNumber = 3,
  };
  // .substrait.DerivationExpression if_condition = 1 [json_name = "ifCondition"];
  bool has_if_condition() const;
  void clear_if_condition() ;
  const ::substrait::DerivationExpression& if_condition() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_if_condition();
  ::substrait::DerivationExpression* mutable_if_condition();
  void set_allocated_if_condition(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_if_condition(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_if_condition();

  private:
  const ::substrait::DerivationExpression& _internal_if_condition() const;
  ::substrait::DerivationExpression* _internal_mutable_if_condition();

  public:
  // .substrait.DerivationExpression if_return = 2 [json_name = "ifReturn"];
  bool has_if_return() const;
  void clear_if_return() ;
  const ::substrait::DerivationExpression& if_return() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_if_return();
  ::substrait::DerivationExpression* mutable_if_return();
  void set_allocated_if_return(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_if_return(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_if_return();

  private:
  const ::substrait::DerivationExpression& _internal_if_return() const;
  ::substrait::DerivationExpression* _internal_mutable_if_return();

  public:
  // .substrait.DerivationExpression else_return = 3 [json_name = "elseReturn"];
  bool has_else_return() const;
  void clear_else_return() ;
  const ::substrait::DerivationExpression& else_return() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_else_return();
  ::substrait::DerivationExpression* mutable_else_return();
  void set_allocated_else_return(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_else_return(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_else_return();

  private:
  const ::substrait::DerivationExpression& _internal_else_return() const;
  ::substrait::DerivationExpression* _internal_mutable_else_return();

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.IfElse)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::DerivationExpression* if_condition_;
    ::substrait::DerivationExpression* if_return_;
    ::substrait::DerivationExpression* else_return_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression_ReturnProgram final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.ReturnProgram) */ {
 public:
  inline DerivationExpression_ReturnProgram() : DerivationExpression_ReturnProgram(nullptr) {}
  ~DerivationExpression_ReturnProgram() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_ReturnProgram(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_ReturnProgram(const DerivationExpression_ReturnProgram& from)
      : DerivationExpression_ReturnProgram(nullptr, from) {}
  DerivationExpression_ReturnProgram(DerivationExpression_ReturnProgram&& from) noexcept
    : DerivationExpression_ReturnProgram() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_ReturnProgram& operator=(const DerivationExpression_ReturnProgram& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_ReturnProgram& operator=(DerivationExpression_ReturnProgram&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_ReturnProgram& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_ReturnProgram* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_ReturnProgram*>(
               &_DerivationExpression_ReturnProgram_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DerivationExpression_ReturnProgram& a, DerivationExpression_ReturnProgram& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_ReturnProgram* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_ReturnProgram* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_ReturnProgram* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_ReturnProgram>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_ReturnProgram& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_ReturnProgram& from) {
    DerivationExpression_ReturnProgram::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_ReturnProgram* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.ReturnProgram";
  }
  protected:
  explicit DerivationExpression_ReturnProgram(::google::protobuf::Arena* arena);
  DerivationExpression_ReturnProgram(::google::protobuf::Arena* arena, const DerivationExpression_ReturnProgram& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using Assignment = DerivationExpression_ReturnProgram_Assignment;

  // accessors -------------------------------------------------------

  enum : int {
    kAssignmentsFieldNumber = 1,
    kFinalExpressionFieldNumber = 2,
  };
  // repeated .substrait.DerivationExpression.ReturnProgram.Assignment assignments = 1 [json_name = "assignments"];
  int assignments_size() const;
  private:
  int _internal_assignments_size() const;

  public:
  void clear_assignments() ;
  ::substrait::DerivationExpression_ReturnProgram_Assignment* mutable_assignments(int index);
  ::google::protobuf::RepeatedPtrField< ::substrait::DerivationExpression_ReturnProgram_Assignment >*
      mutable_assignments();
  private:
  const ::google::protobuf::RepeatedPtrField<::substrait::DerivationExpression_ReturnProgram_Assignment>& _internal_assignments() const;
  ::google::protobuf::RepeatedPtrField<::substrait::DerivationExpression_ReturnProgram_Assignment>* _internal_mutable_assignments();
  public:
  const ::substrait::DerivationExpression_ReturnProgram_Assignment& assignments(int index) const;
  ::substrait::DerivationExpression_ReturnProgram_Assignment* add_assignments();
  const ::google::protobuf::RepeatedPtrField< ::substrait::DerivationExpression_ReturnProgram_Assignment >&
      assignments() const;
  // .substrait.DerivationExpression final_expression = 2 [json_name = "finalExpression"];
  bool has_final_expression() const;
  void clear_final_expression() ;
  const ::substrait::DerivationExpression& final_expression() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_final_expression();
  ::substrait::DerivationExpression* mutable_final_expression();
  void set_allocated_final_expression(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_final_expression(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_final_expression();

  private:
  const ::substrait::DerivationExpression& _internal_final_expression() const;
  ::substrait::DerivationExpression* _internal_mutable_final_expression();

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.ReturnProgram)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 2,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField< ::substrait::DerivationExpression_ReturnProgram_Assignment > assignments_;
    ::substrait::DerivationExpression* final_expression_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression_ReturnProgram_Assignment final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.ReturnProgram.Assignment) */ {
 public:
  inline DerivationExpression_ReturnProgram_Assignment() : DerivationExpression_ReturnProgram_Assignment(nullptr) {}
  ~DerivationExpression_ReturnProgram_Assignment() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_ReturnProgram_Assignment(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_ReturnProgram_Assignment(const DerivationExpression_ReturnProgram_Assignment& from)
      : DerivationExpression_ReturnProgram_Assignment(nullptr, from) {}
  DerivationExpression_ReturnProgram_Assignment(DerivationExpression_ReturnProgram_Assignment&& from) noexcept
    : DerivationExpression_ReturnProgram_Assignment() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_ReturnProgram_Assignment& operator=(const DerivationExpression_ReturnProgram_Assignment& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_ReturnProgram_Assignment& operator=(DerivationExpression_ReturnProgram_Assignment&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_ReturnProgram_Assignment& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_ReturnProgram_Assignment* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_ReturnProgram_Assignment*>(
               &_DerivationExpression_ReturnProgram_Assignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DerivationExpression_ReturnProgram_Assignment& a, DerivationExpression_ReturnProgram_Assignment& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_ReturnProgram_Assignment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_ReturnProgram_Assignment* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_ReturnProgram_Assignment* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_ReturnProgram_Assignment>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_ReturnProgram_Assignment& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_ReturnProgram_Assignment& from) {
    DerivationExpression_ReturnProgram_Assignment::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_ReturnProgram_Assignment* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.ReturnProgram.Assignment";
  }
  protected:
  explicit DerivationExpression_ReturnProgram_Assignment(::google::protobuf::Arena* arena);
  DerivationExpression_ReturnProgram_Assignment(::google::protobuf::Arena* arena, const DerivationExpression_ReturnProgram_Assignment& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kExpressionFieldNumber = 2,
  };
  // string name = 1 [json_name = "name"];
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // .substrait.DerivationExpression expression = 2 [json_name = "expression"];
  bool has_expression() const;
  void clear_expression() ;
  const ::substrait::DerivationExpression& expression() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_expression();
  ::substrait::DerivationExpression* mutable_expression();
  void set_allocated_expression(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_expression(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_expression();

  private:
  const ::substrait::DerivationExpression& _internal_expression() const;
  ::substrait::DerivationExpression* _internal_mutable_expression();

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.ReturnProgram.Assignment)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      68, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::substrait::DerivationExpression* expression_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression_UnaryOp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.UnaryOp) */ {
 public:
  inline DerivationExpression_UnaryOp() : DerivationExpression_UnaryOp(nullptr) {}
  ~DerivationExpression_UnaryOp() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_UnaryOp(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_UnaryOp(const DerivationExpression_UnaryOp& from)
      : DerivationExpression_UnaryOp(nullptr, from) {}
  DerivationExpression_UnaryOp(DerivationExpression_UnaryOp&& from) noexcept
    : DerivationExpression_UnaryOp() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_UnaryOp& operator=(const DerivationExpression_UnaryOp& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_UnaryOp& operator=(DerivationExpression_UnaryOp&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_UnaryOp& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_UnaryOp* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_UnaryOp*>(
               &_DerivationExpression_UnaryOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DerivationExpression_UnaryOp& a, DerivationExpression_UnaryOp& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_UnaryOp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_UnaryOp* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_UnaryOp* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_UnaryOp>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_UnaryOp& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_UnaryOp& from) {
    DerivationExpression_UnaryOp::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_UnaryOp* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.UnaryOp";
  }
  protected:
  explicit DerivationExpression_UnaryOp(::google::protobuf::Arena* arena);
  DerivationExpression_UnaryOp(::google::protobuf::Arena* arena, const DerivationExpression_UnaryOp& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using UnaryOpType = DerivationExpression_UnaryOp_UnaryOpType;
  static constexpr UnaryOpType UNARY_OP_TYPE_UNSPECIFIED = DerivationExpression_UnaryOp_UnaryOpType_UNARY_OP_TYPE_UNSPECIFIED;
  static constexpr UnaryOpType UNARY_OP_TYPE_BOOLEAN_NOT = DerivationExpression_UnaryOp_UnaryOpType_UNARY_OP_TYPE_BOOLEAN_NOT;
  static inline bool UnaryOpType_IsValid(int value) {
    return DerivationExpression_UnaryOp_UnaryOpType_IsValid(value);
  }
  static constexpr UnaryOpType UnaryOpType_MIN = DerivationExpression_UnaryOp_UnaryOpType_UnaryOpType_MIN;
  static constexpr UnaryOpType UnaryOpType_MAX = DerivationExpression_UnaryOp_UnaryOpType_UnaryOpType_MAX;
  static constexpr int UnaryOpType_ARRAYSIZE = DerivationExpression_UnaryOp_UnaryOpType_UnaryOpType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* UnaryOpType_descriptor() {
    return DerivationExpression_UnaryOp_UnaryOpType_descriptor();
  }
  template <typename T>
  static inline const std::string& UnaryOpType_Name(T value) {
    return DerivationExpression_UnaryOp_UnaryOpType_Name(value);
  }
  static inline bool UnaryOpType_Parse(absl::string_view name, UnaryOpType* value) {
    return DerivationExpression_UnaryOp_UnaryOpType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kArgFieldNumber = 2,
    kOpTypeFieldNumber = 1,
  };
  // .substrait.DerivationExpression arg = 2 [json_name = "arg"];
  bool has_arg() const;
  void clear_arg() ;
  const ::substrait::DerivationExpression& arg() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression* release_arg();
  ::substrait::DerivationExpression* mutable_arg();
  void set_allocated_arg(::substrait::DerivationExpression* value);
  void unsafe_arena_set_allocated_arg(::substrait::DerivationExpression* value);
  ::substrait::DerivationExpression* unsafe_arena_release_arg();

  private:
  const ::substrait::DerivationExpression& _internal_arg() const;
  ::substrait::DerivationExpression* _internal_mutable_arg();

  public:
  // .substrait.DerivationExpression.UnaryOp.UnaryOpType op_type = 1 [json_name = "opType"];
  void clear_op_type() ;
  ::substrait::DerivationExpression_UnaryOp_UnaryOpType op_type() const;
  void set_op_type(::substrait::DerivationExpression_UnaryOp_UnaryOpType value);

  private:
  ::substrait::DerivationExpression_UnaryOp_UnaryOpType _internal_op_type() const;
  void _internal_set_op_type(::substrait::DerivationExpression_UnaryOp_UnaryOpType value);

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.UnaryOp)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::substrait::DerivationExpression* arg_;
    int op_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};// -------------------------------------------------------------------

class DerivationExpression_ExpressionNamedStruct final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:substrait.DerivationExpression.ExpressionNamedStruct) */ {
 public:
  inline DerivationExpression_ExpressionNamedStruct() : DerivationExpression_ExpressionNamedStruct(nullptr) {}
  ~DerivationExpression_ExpressionNamedStruct() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DerivationExpression_ExpressionNamedStruct(::google::protobuf::internal::ConstantInitialized);

  inline DerivationExpression_ExpressionNamedStruct(const DerivationExpression_ExpressionNamedStruct& from)
      : DerivationExpression_ExpressionNamedStruct(nullptr, from) {}
  DerivationExpression_ExpressionNamedStruct(DerivationExpression_ExpressionNamedStruct&& from) noexcept
    : DerivationExpression_ExpressionNamedStruct() {
    *this = ::std::move(from);
  }

  inline DerivationExpression_ExpressionNamedStruct& operator=(const DerivationExpression_ExpressionNamedStruct& from) {
    CopyFrom(from);
    return *this;
  }
  inline DerivationExpression_ExpressionNamedStruct& operator=(DerivationExpression_ExpressionNamedStruct&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DerivationExpression_ExpressionNamedStruct& default_instance() {
    return *internal_default_instance();
  }
  static inline const DerivationExpression_ExpressionNamedStruct* internal_default_instance() {
    return reinterpret_cast<const DerivationExpression_ExpressionNamedStruct*>(
               &_DerivationExpression_ExpressionNamedStruct_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DerivationExpression_ExpressionNamedStruct& a, DerivationExpression_ExpressionNamedStruct& b) {
    a.Swap(&b);
  }
  inline void Swap(DerivationExpression_ExpressionNamedStruct* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DerivationExpression_ExpressionNamedStruct* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DerivationExpression_ExpressionNamedStruct* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DerivationExpression_ExpressionNamedStruct>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const DerivationExpression_ExpressionNamedStruct& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const DerivationExpression_ExpressionNamedStruct& from) {
    DerivationExpression_ExpressionNamedStruct::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(DerivationExpression_ExpressionNamedStruct* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "substrait.DerivationExpression.ExpressionNamedStruct";
  }
  protected:
  explicit DerivationExpression_ExpressionNamedStruct(::google::protobuf::Arena* arena);
  DerivationExpression_ExpressionNamedStruct(::google::protobuf::Arena* arena, const DerivationExpression_ExpressionNamedStruct& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNamesFieldNumber = 1,
    kStructFieldNumber = 2,
  };
  // repeated string names = 1 [json_name = "names"];
  int names_size() const;
  private:
  int _internal_names_size() const;

  public:
  void clear_names() ;
  const std::string& names(int index) const;
  std::string* mutable_names(int index);
  void set_names(int index, const std::string& value);
  void set_names(int index, std::string&& value);
  void set_names(int index, const char* value);
  void set_names(int index, const char* value, std::size_t size);
  void set_names(int index, absl::string_view value);
  std::string* add_names();
  void add_names(const std::string& value);
  void add_names(std::string&& value);
  void add_names(const char* value);
  void add_names(const char* value, std::size_t size);
  void add_names(absl::string_view value);
  const ::google::protobuf::RepeatedPtrField<std::string>& names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_names();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_names() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_names();

  public:
  // .substrait.DerivationExpression.ExpressionStruct struct = 2 [json_name = "struct"];
  bool has_struct_() const;
  void clear_struct_() ;
  const ::substrait::DerivationExpression_ExpressionStruct& struct_() const;
  PROTOBUF_NODISCARD ::substrait::DerivationExpression_ExpressionStruct* release_struct_();
  ::substrait::DerivationExpression_ExpressionStruct* mutable_struct_();
  void set_allocated_struct_(::substrait::DerivationExpression_ExpressionStruct* value);
  void unsafe_arena_set_allocated_struct_(::substrait::DerivationExpression_ExpressionStruct* value);
  ::substrait::DerivationExpression_ExpressionStruct* unsafe_arena_release_struct_();

  private:
  const ::substrait::DerivationExpression_ExpressionStruct& _internal_struct_() const;
  ::substrait::DerivationExpression_ExpressionStruct* _internal_mutable_struct_();

  public:
  // @@protoc_insertion_point(class_scope:substrait.DerivationExpression.ExpressionNamedStruct)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 1,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedPtrField<std::string> names_;
    ::substrait::DerivationExpression_ExpressionStruct* struct__;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_substrait_2ftype_5fexpressions_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// DerivationExpression_ExpressionFixedChar

// .substrait.DerivationExpression length = 1 [json_name = "length"];
inline bool DerivationExpression_ExpressionFixedChar::has_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.length_ != nullptr);
  return value;
}
inline void DerivationExpression_ExpressionFixedChar::clear_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.length_ != nullptr) _impl_.length_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionFixedChar::_internal_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.length_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionFixedChar::length() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionFixedChar.length)
  return _internal_length();
}
inline void DerivationExpression_ExpressionFixedChar::unsafe_arena_set_allocated_length(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.length_);
  }
  _impl_.length_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.ExpressionFixedChar.length)
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionFixedChar::release_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* released = _impl_.length_;
  _impl_.length_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionFixedChar::unsafe_arena_release_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.ExpressionFixedChar.length)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* temp = _impl_.length_;
  _impl_.length_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionFixedChar::_internal_mutable_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.length_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.length_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.length_;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionFixedChar::mutable_length() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_length();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ExpressionFixedChar.length)
  return _msg;
}
inline void DerivationExpression_ExpressionFixedChar::set_allocated_length(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.length_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.length_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.ExpressionFixedChar.length)
}

// uint32 variation_pointer = 2 [json_name = "variationPointer"];
inline void DerivationExpression_ExpressionFixedChar::clear_variation_pointer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.variation_pointer_ = 0u;
}
inline ::uint32_t DerivationExpression_ExpressionFixedChar::variation_pointer() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionFixedChar.variation_pointer)
  return _internal_variation_pointer();
}
inline void DerivationExpression_ExpressionFixedChar::set_variation_pointer(::uint32_t value) {
  _internal_set_variation_pointer(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionFixedChar.variation_pointer)
}
inline ::uint32_t DerivationExpression_ExpressionFixedChar::_internal_variation_pointer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.variation_pointer_;
}
inline void DerivationExpression_ExpressionFixedChar::_internal_set_variation_pointer(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.variation_pointer_ = value;
}

// .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
inline void DerivationExpression_ExpressionFixedChar::clear_nullability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nullability_ = 0;
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionFixedChar::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionFixedChar.nullability)
  return _internal_nullability();
}
inline void DerivationExpression_ExpressionFixedChar::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionFixedChar.nullability)
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionFixedChar::_internal_nullability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::substrait::Type_Nullability>(_impl_.nullability_);
}
inline void DerivationExpression_ExpressionFixedChar::_internal_set_nullability(::substrait::Type_Nullability value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nullability_ = value;
}

// -------------------------------------------------------------------

// DerivationExpression_ExpressionVarChar

// .substrait.DerivationExpression length = 1 [json_name = "length"];
inline bool DerivationExpression_ExpressionVarChar::has_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.length_ != nullptr);
  return value;
}
inline void DerivationExpression_ExpressionVarChar::clear_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.length_ != nullptr) _impl_.length_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionVarChar::_internal_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.length_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionVarChar::length() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionVarChar.length)
  return _internal_length();
}
inline void DerivationExpression_ExpressionVarChar::unsafe_arena_set_allocated_length(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.length_);
  }
  _impl_.length_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.ExpressionVarChar.length)
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionVarChar::release_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* released = _impl_.length_;
  _impl_.length_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionVarChar::unsafe_arena_release_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.ExpressionVarChar.length)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* temp = _impl_.length_;
  _impl_.length_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionVarChar::_internal_mutable_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.length_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.length_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.length_;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionVarChar::mutable_length() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_length();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ExpressionVarChar.length)
  return _msg;
}
inline void DerivationExpression_ExpressionVarChar::set_allocated_length(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.length_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.length_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.ExpressionVarChar.length)
}

// uint32 variation_pointer = 2 [json_name = "variationPointer"];
inline void DerivationExpression_ExpressionVarChar::clear_variation_pointer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.variation_pointer_ = 0u;
}
inline ::uint32_t DerivationExpression_ExpressionVarChar::variation_pointer() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionVarChar.variation_pointer)
  return _internal_variation_pointer();
}
inline void DerivationExpression_ExpressionVarChar::set_variation_pointer(::uint32_t value) {
  _internal_set_variation_pointer(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionVarChar.variation_pointer)
}
inline ::uint32_t DerivationExpression_ExpressionVarChar::_internal_variation_pointer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.variation_pointer_;
}
inline void DerivationExpression_ExpressionVarChar::_internal_set_variation_pointer(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.variation_pointer_ = value;
}

// .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
inline void DerivationExpression_ExpressionVarChar::clear_nullability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nullability_ = 0;
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionVarChar::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionVarChar.nullability)
  return _internal_nullability();
}
inline void DerivationExpression_ExpressionVarChar::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionVarChar.nullability)
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionVarChar::_internal_nullability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::substrait::Type_Nullability>(_impl_.nullability_);
}
inline void DerivationExpression_ExpressionVarChar::_internal_set_nullability(::substrait::Type_Nullability value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nullability_ = value;
}

// -------------------------------------------------------------------

// DerivationExpression_ExpressionFixedBinary

// .substrait.DerivationExpression length = 1 [json_name = "length"];
inline bool DerivationExpression_ExpressionFixedBinary::has_length() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.length_ != nullptr);
  return value;
}
inline void DerivationExpression_ExpressionFixedBinary::clear_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.length_ != nullptr) _impl_.length_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionFixedBinary::_internal_length() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.length_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionFixedBinary::length() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionFixedBinary.length)
  return _internal_length();
}
inline void DerivationExpression_ExpressionFixedBinary::unsafe_arena_set_allocated_length(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.length_);
  }
  _impl_.length_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.ExpressionFixedBinary.length)
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionFixedBinary::release_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* released = _impl_.length_;
  _impl_.length_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionFixedBinary::unsafe_arena_release_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.ExpressionFixedBinary.length)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* temp = _impl_.length_;
  _impl_.length_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionFixedBinary::_internal_mutable_length() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.length_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.length_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.length_;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionFixedBinary::mutable_length() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_length();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ExpressionFixedBinary.length)
  return _msg;
}
inline void DerivationExpression_ExpressionFixedBinary::set_allocated_length(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.length_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.length_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.ExpressionFixedBinary.length)
}

// uint32 variation_pointer = 2 [json_name = "variationPointer"];
inline void DerivationExpression_ExpressionFixedBinary::clear_variation_pointer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.variation_pointer_ = 0u;
}
inline ::uint32_t DerivationExpression_ExpressionFixedBinary::variation_pointer() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionFixedBinary.variation_pointer)
  return _internal_variation_pointer();
}
inline void DerivationExpression_ExpressionFixedBinary::set_variation_pointer(::uint32_t value) {
  _internal_set_variation_pointer(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionFixedBinary.variation_pointer)
}
inline ::uint32_t DerivationExpression_ExpressionFixedBinary::_internal_variation_pointer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.variation_pointer_;
}
inline void DerivationExpression_ExpressionFixedBinary::_internal_set_variation_pointer(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.variation_pointer_ = value;
}

// .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
inline void DerivationExpression_ExpressionFixedBinary::clear_nullability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nullability_ = 0;
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionFixedBinary::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionFixedBinary.nullability)
  return _internal_nullability();
}
inline void DerivationExpression_ExpressionFixedBinary::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionFixedBinary.nullability)
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionFixedBinary::_internal_nullability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::substrait::Type_Nullability>(_impl_.nullability_);
}
inline void DerivationExpression_ExpressionFixedBinary::_internal_set_nullability(::substrait::Type_Nullability value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nullability_ = value;
}

// -------------------------------------------------------------------

// DerivationExpression_ExpressionDecimal

// .substrait.DerivationExpression scale = 1 [json_name = "scale"];
inline bool DerivationExpression_ExpressionDecimal::has_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scale_ != nullptr);
  return value;
}
inline void DerivationExpression_ExpressionDecimal::clear_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.scale_ != nullptr) _impl_.scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionDecimal::_internal_scale() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionDecimal::scale() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionDecimal.scale)
  return _internal_scale();
}
inline void DerivationExpression_ExpressionDecimal::unsafe_arena_set_allocated_scale(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.scale_);
  }
  _impl_.scale_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.ExpressionDecimal.scale)
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionDecimal::release_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* released = _impl_.scale_;
  _impl_.scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionDecimal::unsafe_arena_release_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.ExpressionDecimal.scale)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionDecimal::_internal_mutable_scale() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.scale_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.scale_;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionDecimal::mutable_scale() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_scale();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ExpressionDecimal.scale)
  return _msg;
}
inline void DerivationExpression_ExpressionDecimal::set_allocated_scale(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.scale_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.scale_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.ExpressionDecimal.scale)
}

// .substrait.DerivationExpression precision = 2 [json_name = "precision"];
inline bool DerivationExpression_ExpressionDecimal::has_precision() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.precision_ != nullptr);
  return value;
}
inline void DerivationExpression_ExpressionDecimal::clear_precision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.precision_ != nullptr) _impl_.precision_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionDecimal::_internal_precision() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.precision_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionDecimal::precision() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionDecimal.precision)
  return _internal_precision();
}
inline void DerivationExpression_ExpressionDecimal::unsafe_arena_set_allocated_precision(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.precision_);
  }
  _impl_.precision_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.ExpressionDecimal.precision)
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionDecimal::release_precision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::DerivationExpression* released = _impl_.precision_;
  _impl_.precision_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionDecimal::unsafe_arena_release_precision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.ExpressionDecimal.precision)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::DerivationExpression* temp = _impl_.precision_;
  _impl_.precision_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionDecimal::_internal_mutable_precision() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.precision_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.precision_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.precision_;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionDecimal::mutable_precision() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_precision();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ExpressionDecimal.precision)
  return _msg;
}
inline void DerivationExpression_ExpressionDecimal::set_allocated_precision(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.precision_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.precision_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.ExpressionDecimal.precision)
}

// uint32 variation_pointer = 3 [json_name = "variationPointer"];
inline void DerivationExpression_ExpressionDecimal::clear_variation_pointer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.variation_pointer_ = 0u;
}
inline ::uint32_t DerivationExpression_ExpressionDecimal::variation_pointer() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionDecimal.variation_pointer)
  return _internal_variation_pointer();
}
inline void DerivationExpression_ExpressionDecimal::set_variation_pointer(::uint32_t value) {
  _internal_set_variation_pointer(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionDecimal.variation_pointer)
}
inline ::uint32_t DerivationExpression_ExpressionDecimal::_internal_variation_pointer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.variation_pointer_;
}
inline void DerivationExpression_ExpressionDecimal::_internal_set_variation_pointer(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.variation_pointer_ = value;
}

// .substrait.Type.Nullability nullability = 4 [json_name = "nullability"];
inline void DerivationExpression_ExpressionDecimal::clear_nullability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nullability_ = 0;
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionDecimal::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionDecimal.nullability)
  return _internal_nullability();
}
inline void DerivationExpression_ExpressionDecimal::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionDecimal.nullability)
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionDecimal::_internal_nullability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::substrait::Type_Nullability>(_impl_.nullability_);
}
inline void DerivationExpression_ExpressionDecimal::_internal_set_nullability(::substrait::Type_Nullability value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nullability_ = value;
}

// -------------------------------------------------------------------

// DerivationExpression_ExpressionStruct

// repeated .substrait.DerivationExpression types = 1 [json_name = "types"];
inline int DerivationExpression_ExpressionStruct::_internal_types_size() const {
  return _internal_types().size();
}
inline int DerivationExpression_ExpressionStruct::types_size() const {
  return _internal_types_size();
}
inline void DerivationExpression_ExpressionStruct::clear_types() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.types_.Clear();
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionStruct::mutable_types(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ExpressionStruct.types)
  return _internal_mutable_types()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::DerivationExpression>* DerivationExpression_ExpressionStruct::mutable_types()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.DerivationExpression.ExpressionStruct.types)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_types();
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionStruct::types(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionStruct.types)
  return _internal_types().Get(index);
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionStruct::add_types() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::substrait::DerivationExpression* _add = _internal_mutable_types()->Add();
  // @@protoc_insertion_point(field_add:substrait.DerivationExpression.ExpressionStruct.types)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::DerivationExpression>& DerivationExpression_ExpressionStruct::types() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.DerivationExpression.ExpressionStruct.types)
  return _internal_types();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::DerivationExpression>&
DerivationExpression_ExpressionStruct::_internal_types() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.types_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::DerivationExpression>*
DerivationExpression_ExpressionStruct::_internal_mutable_types() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.types_;
}

// uint32 variation_pointer = 2 [json_name = "variationPointer"];
inline void DerivationExpression_ExpressionStruct::clear_variation_pointer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.variation_pointer_ = 0u;
}
inline ::uint32_t DerivationExpression_ExpressionStruct::variation_pointer() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionStruct.variation_pointer)
  return _internal_variation_pointer();
}
inline void DerivationExpression_ExpressionStruct::set_variation_pointer(::uint32_t value) {
  _internal_set_variation_pointer(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionStruct.variation_pointer)
}
inline ::uint32_t DerivationExpression_ExpressionStruct::_internal_variation_pointer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.variation_pointer_;
}
inline void DerivationExpression_ExpressionStruct::_internal_set_variation_pointer(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.variation_pointer_ = value;
}

// .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
inline void DerivationExpression_ExpressionStruct::clear_nullability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nullability_ = 0;
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionStruct::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionStruct.nullability)
  return _internal_nullability();
}
inline void DerivationExpression_ExpressionStruct::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionStruct.nullability)
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionStruct::_internal_nullability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::substrait::Type_Nullability>(_impl_.nullability_);
}
inline void DerivationExpression_ExpressionStruct::_internal_set_nullability(::substrait::Type_Nullability value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nullability_ = value;
}

// -------------------------------------------------------------------

// DerivationExpression_ExpressionNamedStruct

// repeated string names = 1 [json_name = "names"];
inline int DerivationExpression_ExpressionNamedStruct::_internal_names_size() const {
  return _internal_names().size();
}
inline int DerivationExpression_ExpressionNamedStruct::names_size() const {
  return _internal_names_size();
}
inline void DerivationExpression_ExpressionNamedStruct::clear_names() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.names_.Clear();
}
inline std::string* DerivationExpression_ExpressionNamedStruct::add_names()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  std::string* _s = _internal_mutable_names()->Add();
  // @@protoc_insertion_point(field_add_mutable:substrait.DerivationExpression.ExpressionNamedStruct.names)
  return _s;
}
inline const std::string& DerivationExpression_ExpressionNamedStruct::names(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionNamedStruct.names)
  return _internal_names().Get(index);
}
inline std::string* DerivationExpression_ExpressionNamedStruct::mutable_names(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ExpressionNamedStruct.names)
  return _internal_mutable_names()->Mutable(index);
}
inline void DerivationExpression_ExpressionNamedStruct::set_names(int index, const std::string& value) {
  _internal_mutable_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionNamedStruct.names)
}
inline void DerivationExpression_ExpressionNamedStruct::set_names(int index, std::string&& value) {
  _internal_mutable_names()->Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionNamedStruct.names)
}
inline void DerivationExpression_ExpressionNamedStruct::set_names(int index, const char* value) {
  ABSL_DCHECK(value != nullptr);
  _internal_mutable_names()->Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:substrait.DerivationExpression.ExpressionNamedStruct.names)
}
inline void DerivationExpression_ExpressionNamedStruct::set_names(int index, const char* value,
                              std::size_t size) {
  _internal_mutable_names()->Mutable(index)->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:substrait.DerivationExpression.ExpressionNamedStruct.names)
}
inline void DerivationExpression_ExpressionNamedStruct::set_names(int index, absl::string_view value) {
  _internal_mutable_names()->Mutable(index)->assign(value.data(),
                                                     value.size());
  // @@protoc_insertion_point(field_set_string_piece:substrait.DerivationExpression.ExpressionNamedStruct.names)
}
inline void DerivationExpression_ExpressionNamedStruct::add_names(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add:substrait.DerivationExpression.ExpressionNamedStruct.names)
}
inline void DerivationExpression_ExpressionNamedStruct::add_names(std::string&& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add(std::move(value));
  // @@protoc_insertion_point(field_add:substrait.DerivationExpression.ExpressionNamedStruct.names)
}
inline void DerivationExpression_ExpressionNamedStruct::add_names(const char* value) {
  ABSL_DCHECK(value != nullptr);
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:substrait.DerivationExpression.ExpressionNamedStruct.names)
}
inline void DerivationExpression_ExpressionNamedStruct::add_names(const char* value, std::size_t size) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(
      reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:substrait.DerivationExpression.ExpressionNamedStruct.names)
}
inline void DerivationExpression_ExpressionNamedStruct::add_names(absl::string_view value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _internal_mutable_names()->Add()->assign(value.data(), value.size());
  // @@protoc_insertion_point(field_add_string_piece:substrait.DerivationExpression.ExpressionNamedStruct.names)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DerivationExpression_ExpressionNamedStruct::names() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.DerivationExpression.ExpressionNamedStruct.names)
  return _internal_names();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DerivationExpression_ExpressionNamedStruct::mutable_names() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.DerivationExpression.ExpressionNamedStruct.names)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_names();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
DerivationExpression_ExpressionNamedStruct::_internal_names() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.names_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
DerivationExpression_ExpressionNamedStruct::_internal_mutable_names() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.names_;
}

// .substrait.DerivationExpression.ExpressionStruct struct = 2 [json_name = "struct"];
inline bool DerivationExpression_ExpressionNamedStruct::has_struct_() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.struct__ != nullptr);
  return value;
}
inline void DerivationExpression_ExpressionNamedStruct::clear_struct_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.struct__ != nullptr) _impl_.struct__->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::DerivationExpression_ExpressionStruct& DerivationExpression_ExpressionNamedStruct::_internal_struct_() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression_ExpressionStruct* p = _impl_.struct__;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression_ExpressionStruct&>(::substrait::_DerivationExpression_ExpressionStruct_default_instance_);
}
inline const ::substrait::DerivationExpression_ExpressionStruct& DerivationExpression_ExpressionNamedStruct::struct_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionNamedStruct.struct)
  return _internal_struct_();
}
inline void DerivationExpression_ExpressionNamedStruct::unsafe_arena_set_allocated_struct_(::substrait::DerivationExpression_ExpressionStruct* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.struct__);
  }
  _impl_.struct__ = reinterpret_cast<::substrait::DerivationExpression_ExpressionStruct*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.ExpressionNamedStruct.struct)
}
inline ::substrait::DerivationExpression_ExpressionStruct* DerivationExpression_ExpressionNamedStruct::release_struct_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression_ExpressionStruct* released = _impl_.struct__;
  _impl_.struct__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression_ExpressionStruct* DerivationExpression_ExpressionNamedStruct::unsafe_arena_release_struct_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.ExpressionNamedStruct.struct)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression_ExpressionStruct* temp = _impl_.struct__;
  _impl_.struct__ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression_ExpressionStruct* DerivationExpression_ExpressionNamedStruct::_internal_mutable_struct_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.struct__ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression_ExpressionStruct>(GetArena());
    _impl_.struct__ = reinterpret_cast<::substrait::DerivationExpression_ExpressionStruct*>(p);
  }
  return _impl_.struct__;
}
inline ::substrait::DerivationExpression_ExpressionStruct* DerivationExpression_ExpressionNamedStruct::mutable_struct_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression_ExpressionStruct* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ExpressionNamedStruct.struct)
  return _msg;
}
inline void DerivationExpression_ExpressionNamedStruct::set_allocated_struct_(::substrait::DerivationExpression_ExpressionStruct* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression_ExpressionStruct*>(_impl_.struct__);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression_ExpressionStruct*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.struct__ = reinterpret_cast<::substrait::DerivationExpression_ExpressionStruct*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.ExpressionNamedStruct.struct)
}

// -------------------------------------------------------------------

// DerivationExpression_ExpressionList

// .substrait.DerivationExpression type = 1 [json_name = "type"];
inline bool DerivationExpression_ExpressionList::has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.type_ != nullptr);
  return value;
}
inline void DerivationExpression_ExpressionList::clear_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.type_ != nullptr) _impl_.type_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionList::_internal_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.type_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionList::type() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionList.type)
  return _internal_type();
}
inline void DerivationExpression_ExpressionList::unsafe_arena_set_allocated_type(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.type_);
  }
  _impl_.type_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.ExpressionList.type)
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionList::release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* released = _impl_.type_;
  _impl_.type_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionList::unsafe_arena_release_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.ExpressionList.type)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* temp = _impl_.type_;
  _impl_.type_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionList::_internal_mutable_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.type_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.type_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.type_;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionList::mutable_type() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ExpressionList.type)
  return _msg;
}
inline void DerivationExpression_ExpressionList::set_allocated_type(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.type_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.type_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.ExpressionList.type)
}

// uint32 variation_pointer = 2 [json_name = "variationPointer"];
inline void DerivationExpression_ExpressionList::clear_variation_pointer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.variation_pointer_ = 0u;
}
inline ::uint32_t DerivationExpression_ExpressionList::variation_pointer() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionList.variation_pointer)
  return _internal_variation_pointer();
}
inline void DerivationExpression_ExpressionList::set_variation_pointer(::uint32_t value) {
  _internal_set_variation_pointer(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionList.variation_pointer)
}
inline ::uint32_t DerivationExpression_ExpressionList::_internal_variation_pointer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.variation_pointer_;
}
inline void DerivationExpression_ExpressionList::_internal_set_variation_pointer(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.variation_pointer_ = value;
}

// .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
inline void DerivationExpression_ExpressionList::clear_nullability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nullability_ = 0;
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionList::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionList.nullability)
  return _internal_nullability();
}
inline void DerivationExpression_ExpressionList::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionList.nullability)
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionList::_internal_nullability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::substrait::Type_Nullability>(_impl_.nullability_);
}
inline void DerivationExpression_ExpressionList::_internal_set_nullability(::substrait::Type_Nullability value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nullability_ = value;
}

// -------------------------------------------------------------------

// DerivationExpression_ExpressionMap

// .substrait.DerivationExpression key = 1 [json_name = "key"];
inline bool DerivationExpression_ExpressionMap::has_key() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.key_ != nullptr);
  return value;
}
inline void DerivationExpression_ExpressionMap::clear_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.key_ != nullptr) _impl_.key_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionMap::_internal_key() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.key_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionMap::key() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionMap.key)
  return _internal_key();
}
inline void DerivationExpression_ExpressionMap::unsafe_arena_set_allocated_key(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.key_);
  }
  _impl_.key_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.ExpressionMap.key)
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionMap::release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* released = _impl_.key_;
  _impl_.key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionMap::unsafe_arena_release_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.ExpressionMap.key)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* temp = _impl_.key_;
  _impl_.key_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionMap::_internal_mutable_key() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.key_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.key_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.key_;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionMap::mutable_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ExpressionMap.key)
  return _msg;
}
inline void DerivationExpression_ExpressionMap::set_allocated_key(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.key_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.key_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.ExpressionMap.key)
}

// .substrait.DerivationExpression value = 2 [json_name = "value"];
inline bool DerivationExpression_ExpressionMap::has_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.value_ != nullptr);
  return value;
}
inline void DerivationExpression_ExpressionMap::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.value_ != nullptr) _impl_.value_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionMap::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.value_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_ExpressionMap::value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionMap.value)
  return _internal_value();
}
inline void DerivationExpression_ExpressionMap::unsafe_arena_set_allocated_value(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.value_);
  }
  _impl_.value_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.ExpressionMap.value)
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionMap::release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::DerivationExpression* released = _impl_.value_;
  _impl_.value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionMap::unsafe_arena_release_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.ExpressionMap.value)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::DerivationExpression* temp = _impl_.value_;
  _impl_.value_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionMap::_internal_mutable_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.value_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.value_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.value_;
}
inline ::substrait::DerivationExpression* DerivationExpression_ExpressionMap::mutable_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ExpressionMap.value)
  return _msg;
}
inline void DerivationExpression_ExpressionMap::set_allocated_value(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.value_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.value_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.ExpressionMap.value)
}

// uint32 variation_pointer = 3 [json_name = "variationPointer"];
inline void DerivationExpression_ExpressionMap::clear_variation_pointer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.variation_pointer_ = 0u;
}
inline ::uint32_t DerivationExpression_ExpressionMap::variation_pointer() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionMap.variation_pointer)
  return _internal_variation_pointer();
}
inline void DerivationExpression_ExpressionMap::set_variation_pointer(::uint32_t value) {
  _internal_set_variation_pointer(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionMap.variation_pointer)
}
inline ::uint32_t DerivationExpression_ExpressionMap::_internal_variation_pointer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.variation_pointer_;
}
inline void DerivationExpression_ExpressionMap::_internal_set_variation_pointer(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.variation_pointer_ = value;
}

// .substrait.Type.Nullability nullability = 4 [json_name = "nullability"];
inline void DerivationExpression_ExpressionMap::clear_nullability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nullability_ = 0;
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionMap::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionMap.nullability)
  return _internal_nullability();
}
inline void DerivationExpression_ExpressionMap::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionMap.nullability)
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionMap::_internal_nullability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::substrait::Type_Nullability>(_impl_.nullability_);
}
inline void DerivationExpression_ExpressionMap::_internal_set_nullability(::substrait::Type_Nullability value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nullability_ = value;
}

// -------------------------------------------------------------------

// DerivationExpression_ExpressionUserDefined

// uint32 type_pointer = 1 [json_name = "typePointer"];
inline void DerivationExpression_ExpressionUserDefined::clear_type_pointer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.type_pointer_ = 0u;
}
inline ::uint32_t DerivationExpression_ExpressionUserDefined::type_pointer() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionUserDefined.type_pointer)
  return _internal_type_pointer();
}
inline void DerivationExpression_ExpressionUserDefined::set_type_pointer(::uint32_t value) {
  _internal_set_type_pointer(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionUserDefined.type_pointer)
}
inline ::uint32_t DerivationExpression_ExpressionUserDefined::_internal_type_pointer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.type_pointer_;
}
inline void DerivationExpression_ExpressionUserDefined::_internal_set_type_pointer(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.type_pointer_ = value;
}

// uint32 variation_pointer = 2 [json_name = "variationPointer"];
inline void DerivationExpression_ExpressionUserDefined::clear_variation_pointer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.variation_pointer_ = 0u;
}
inline ::uint32_t DerivationExpression_ExpressionUserDefined::variation_pointer() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionUserDefined.variation_pointer)
  return _internal_variation_pointer();
}
inline void DerivationExpression_ExpressionUserDefined::set_variation_pointer(::uint32_t value) {
  _internal_set_variation_pointer(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionUserDefined.variation_pointer)
}
inline ::uint32_t DerivationExpression_ExpressionUserDefined::_internal_variation_pointer() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.variation_pointer_;
}
inline void DerivationExpression_ExpressionUserDefined::_internal_set_variation_pointer(::uint32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.variation_pointer_ = value;
}

// .substrait.Type.Nullability nullability = 3 [json_name = "nullability"];
inline void DerivationExpression_ExpressionUserDefined::clear_nullability() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.nullability_ = 0;
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionUserDefined::nullability() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ExpressionUserDefined.nullability)
  return _internal_nullability();
}
inline void DerivationExpression_ExpressionUserDefined::set_nullability(::substrait::Type_Nullability value) {
  _internal_set_nullability(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ExpressionUserDefined.nullability)
}
inline ::substrait::Type_Nullability DerivationExpression_ExpressionUserDefined::_internal_nullability() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::substrait::Type_Nullability>(_impl_.nullability_);
}
inline void DerivationExpression_ExpressionUserDefined::_internal_set_nullability(::substrait::Type_Nullability value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.nullability_ = value;
}

// -------------------------------------------------------------------

// DerivationExpression_IfElse

// .substrait.DerivationExpression if_condition = 1 [json_name = "ifCondition"];
inline bool DerivationExpression_IfElse::has_if_condition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.if_condition_ != nullptr);
  return value;
}
inline void DerivationExpression_IfElse::clear_if_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.if_condition_ != nullptr) _impl_.if_condition_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_IfElse::_internal_if_condition() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.if_condition_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_IfElse::if_condition() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.IfElse.if_condition)
  return _internal_if_condition();
}
inline void DerivationExpression_IfElse::unsafe_arena_set_allocated_if_condition(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.if_condition_);
  }
  _impl_.if_condition_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.IfElse.if_condition)
}
inline ::substrait::DerivationExpression* DerivationExpression_IfElse::release_if_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* released = _impl_.if_condition_;
  _impl_.if_condition_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_IfElse::unsafe_arena_release_if_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.IfElse.if_condition)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* temp = _impl_.if_condition_;
  _impl_.if_condition_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_IfElse::_internal_mutable_if_condition() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.if_condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.if_condition_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.if_condition_;
}
inline ::substrait::DerivationExpression* DerivationExpression_IfElse::mutable_if_condition() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_if_condition();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.IfElse.if_condition)
  return _msg;
}
inline void DerivationExpression_IfElse::set_allocated_if_condition(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.if_condition_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.if_condition_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.IfElse.if_condition)
}

// .substrait.DerivationExpression if_return = 2 [json_name = "ifReturn"];
inline bool DerivationExpression_IfElse::has_if_return() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.if_return_ != nullptr);
  return value;
}
inline void DerivationExpression_IfElse::clear_if_return() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.if_return_ != nullptr) _impl_.if_return_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_IfElse::_internal_if_return() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.if_return_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_IfElse::if_return() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.IfElse.if_return)
  return _internal_if_return();
}
inline void DerivationExpression_IfElse::unsafe_arena_set_allocated_if_return(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.if_return_);
  }
  _impl_.if_return_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.IfElse.if_return)
}
inline ::substrait::DerivationExpression* DerivationExpression_IfElse::release_if_return() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::DerivationExpression* released = _impl_.if_return_;
  _impl_.if_return_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_IfElse::unsafe_arena_release_if_return() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.IfElse.if_return)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::DerivationExpression* temp = _impl_.if_return_;
  _impl_.if_return_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_IfElse::_internal_mutable_if_return() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.if_return_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.if_return_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.if_return_;
}
inline ::substrait::DerivationExpression* DerivationExpression_IfElse::mutable_if_return() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_if_return();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.IfElse.if_return)
  return _msg;
}
inline void DerivationExpression_IfElse::set_allocated_if_return(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.if_return_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.if_return_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.IfElse.if_return)
}

// .substrait.DerivationExpression else_return = 3 [json_name = "elseReturn"];
inline bool DerivationExpression_IfElse::has_else_return() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.else_return_ != nullptr);
  return value;
}
inline void DerivationExpression_IfElse::clear_else_return() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.else_return_ != nullptr) _impl_.else_return_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_IfElse::_internal_else_return() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.else_return_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_IfElse::else_return() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.IfElse.else_return)
  return _internal_else_return();
}
inline void DerivationExpression_IfElse::unsafe_arena_set_allocated_else_return(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.else_return_);
  }
  _impl_.else_return_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.IfElse.else_return)
}
inline ::substrait::DerivationExpression* DerivationExpression_IfElse::release_else_return() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::DerivationExpression* released = _impl_.else_return_;
  _impl_.else_return_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_IfElse::unsafe_arena_release_else_return() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.IfElse.else_return)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::substrait::DerivationExpression* temp = _impl_.else_return_;
  _impl_.else_return_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_IfElse::_internal_mutable_else_return() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.else_return_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.else_return_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.else_return_;
}
inline ::substrait::DerivationExpression* DerivationExpression_IfElse::mutable_else_return() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_else_return();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.IfElse.else_return)
  return _msg;
}
inline void DerivationExpression_IfElse::set_allocated_else_return(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.else_return_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.else_return_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.IfElse.else_return)
}

// -------------------------------------------------------------------

// DerivationExpression_UnaryOp

// .substrait.DerivationExpression.UnaryOp.UnaryOpType op_type = 1 [json_name = "opType"];
inline void DerivationExpression_UnaryOp::clear_op_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_type_ = 0;
}
inline ::substrait::DerivationExpression_UnaryOp_UnaryOpType DerivationExpression_UnaryOp::op_type() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.UnaryOp.op_type)
  return _internal_op_type();
}
inline void DerivationExpression_UnaryOp::set_op_type(::substrait::DerivationExpression_UnaryOp_UnaryOpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.UnaryOp.op_type)
}
inline ::substrait::DerivationExpression_UnaryOp_UnaryOpType DerivationExpression_UnaryOp::_internal_op_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::substrait::DerivationExpression_UnaryOp_UnaryOpType>(_impl_.op_type_);
}
inline void DerivationExpression_UnaryOp::_internal_set_op_type(::substrait::DerivationExpression_UnaryOp_UnaryOpType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.op_type_ = value;
}

// .substrait.DerivationExpression arg = 2 [json_name = "arg"];
inline bool DerivationExpression_UnaryOp::has_arg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arg_ != nullptr);
  return value;
}
inline void DerivationExpression_UnaryOp::clear_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.arg_ != nullptr) _impl_.arg_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_UnaryOp::_internal_arg() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.arg_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_UnaryOp::arg() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.UnaryOp.arg)
  return _internal_arg();
}
inline void DerivationExpression_UnaryOp::unsafe_arena_set_allocated_arg(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arg_);
  }
  _impl_.arg_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.UnaryOp.arg)
}
inline ::substrait::DerivationExpression* DerivationExpression_UnaryOp::release_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* released = _impl_.arg_;
  _impl_.arg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_UnaryOp::unsafe_arena_release_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.UnaryOp.arg)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* temp = _impl_.arg_;
  _impl_.arg_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_UnaryOp::_internal_mutable_arg() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.arg_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.arg_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.arg_;
}
inline ::substrait::DerivationExpression* DerivationExpression_UnaryOp::mutable_arg() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_arg();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.UnaryOp.arg)
  return _msg;
}
inline void DerivationExpression_UnaryOp::set_allocated_arg(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.arg_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.arg_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.UnaryOp.arg)
}

// -------------------------------------------------------------------

// DerivationExpression_BinaryOp

// .substrait.DerivationExpression.BinaryOp.BinaryOpType op_type = 1 [json_name = "opType"];
inline void DerivationExpression_BinaryOp::clear_op_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.op_type_ = 0;
}
inline ::substrait::DerivationExpression_BinaryOp_BinaryOpType DerivationExpression_BinaryOp::op_type() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.BinaryOp.op_type)
  return _internal_op_type();
}
inline void DerivationExpression_BinaryOp::set_op_type(::substrait::DerivationExpression_BinaryOp_BinaryOpType value) {
  _internal_set_op_type(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.BinaryOp.op_type)
}
inline ::substrait::DerivationExpression_BinaryOp_BinaryOpType DerivationExpression_BinaryOp::_internal_op_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::substrait::DerivationExpression_BinaryOp_BinaryOpType>(_impl_.op_type_);
}
inline void DerivationExpression_BinaryOp::_internal_set_op_type(::substrait::DerivationExpression_BinaryOp_BinaryOpType value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.op_type_ = value;
}

// .substrait.DerivationExpression arg1 = 2 [json_name = "arg1"];
inline bool DerivationExpression_BinaryOp::has_arg1() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arg1_ != nullptr);
  return value;
}
inline void DerivationExpression_BinaryOp::clear_arg1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.arg1_ != nullptr) _impl_.arg1_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_BinaryOp::_internal_arg1() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.arg1_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_BinaryOp::arg1() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.BinaryOp.arg1)
  return _internal_arg1();
}
inline void DerivationExpression_BinaryOp::unsafe_arena_set_allocated_arg1(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arg1_);
  }
  _impl_.arg1_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.BinaryOp.arg1)
}
inline ::substrait::DerivationExpression* DerivationExpression_BinaryOp::release_arg1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* released = _impl_.arg1_;
  _impl_.arg1_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_BinaryOp::unsafe_arena_release_arg1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.BinaryOp.arg1)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* temp = _impl_.arg1_;
  _impl_.arg1_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_BinaryOp::_internal_mutable_arg1() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.arg1_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.arg1_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.arg1_;
}
inline ::substrait::DerivationExpression* DerivationExpression_BinaryOp::mutable_arg1() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_arg1();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.BinaryOp.arg1)
  return _msg;
}
inline void DerivationExpression_BinaryOp::set_allocated_arg1(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.arg1_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.arg1_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.BinaryOp.arg1)
}

// .substrait.DerivationExpression arg2 = 3 [json_name = "arg2"];
inline bool DerivationExpression_BinaryOp::has_arg2() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.arg2_ != nullptr);
  return value;
}
inline void DerivationExpression_BinaryOp::clear_arg2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.arg2_ != nullptr) _impl_.arg2_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_BinaryOp::_internal_arg2() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.arg2_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_BinaryOp::arg2() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.BinaryOp.arg2)
  return _internal_arg2();
}
inline void DerivationExpression_BinaryOp::unsafe_arena_set_allocated_arg2(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.arg2_);
  }
  _impl_.arg2_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.BinaryOp.arg2)
}
inline ::substrait::DerivationExpression* DerivationExpression_BinaryOp::release_arg2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::DerivationExpression* released = _impl_.arg2_;
  _impl_.arg2_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_BinaryOp::unsafe_arena_release_arg2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.BinaryOp.arg2)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::substrait::DerivationExpression* temp = _impl_.arg2_;
  _impl_.arg2_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_BinaryOp::_internal_mutable_arg2() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.arg2_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.arg2_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.arg2_;
}
inline ::substrait::DerivationExpression* DerivationExpression_BinaryOp::mutable_arg2() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_arg2();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.BinaryOp.arg2)
  return _msg;
}
inline void DerivationExpression_BinaryOp::set_allocated_arg2(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.arg2_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.arg2_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.BinaryOp.arg2)
}

// -------------------------------------------------------------------

// DerivationExpression_ReturnProgram_Assignment

// string name = 1 [json_name = "name"];
inline void DerivationExpression_ReturnProgram_Assignment::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& DerivationExpression_ReturnProgram_Assignment::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ReturnProgram.Assignment.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivationExpression_ReturnProgram_Assignment::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.ReturnProgram.Assignment.name)
}
inline std::string* DerivationExpression_ReturnProgram_Assignment::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ReturnProgram.Assignment.name)
  return _s;
}
inline const std::string& DerivationExpression_ReturnProgram_Assignment::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void DerivationExpression_ReturnProgram_Assignment::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* DerivationExpression_ReturnProgram_Assignment::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* DerivationExpression_ReturnProgram_Assignment::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.ReturnProgram.Assignment.name)
  return _impl_.name_.Release();
}
inline void DerivationExpression_ReturnProgram_Assignment::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.ReturnProgram.Assignment.name)
}

// .substrait.DerivationExpression expression = 2 [json_name = "expression"];
inline bool DerivationExpression_ReturnProgram_Assignment::has_expression() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.expression_ != nullptr);
  return value;
}
inline void DerivationExpression_ReturnProgram_Assignment::clear_expression() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.expression_ != nullptr) _impl_.expression_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_ReturnProgram_Assignment::_internal_expression() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.expression_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_ReturnProgram_Assignment::expression() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ReturnProgram.Assignment.expression)
  return _internal_expression();
}
inline void DerivationExpression_ReturnProgram_Assignment::unsafe_arena_set_allocated_expression(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.expression_);
  }
  _impl_.expression_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.ReturnProgram.Assignment.expression)
}
inline ::substrait::DerivationExpression* DerivationExpression_ReturnProgram_Assignment::release_expression() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* released = _impl_.expression_;
  _impl_.expression_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_ReturnProgram_Assignment::unsafe_arena_release_expression() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.ReturnProgram.Assignment.expression)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* temp = _impl_.expression_;
  _impl_.expression_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_ReturnProgram_Assignment::_internal_mutable_expression() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.expression_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.expression_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.expression_;
}
inline ::substrait::DerivationExpression* DerivationExpression_ReturnProgram_Assignment::mutable_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_expression();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ReturnProgram.Assignment.expression)
  return _msg;
}
inline void DerivationExpression_ReturnProgram_Assignment::set_allocated_expression(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.expression_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.expression_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.ReturnProgram.Assignment.expression)
}

// -------------------------------------------------------------------

// DerivationExpression_ReturnProgram

// repeated .substrait.DerivationExpression.ReturnProgram.Assignment assignments = 1 [json_name = "assignments"];
inline int DerivationExpression_ReturnProgram::_internal_assignments_size() const {
  return _internal_assignments().size();
}
inline int DerivationExpression_ReturnProgram::assignments_size() const {
  return _internal_assignments_size();
}
inline void DerivationExpression_ReturnProgram::clear_assignments() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.assignments_.Clear();
}
inline ::substrait::DerivationExpression_ReturnProgram_Assignment* DerivationExpression_ReturnProgram::mutable_assignments(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ReturnProgram.assignments)
  return _internal_mutable_assignments()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::substrait::DerivationExpression_ReturnProgram_Assignment>* DerivationExpression_ReturnProgram::mutable_assignments()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:substrait.DerivationExpression.ReturnProgram.assignments)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_assignments();
}
inline const ::substrait::DerivationExpression_ReturnProgram_Assignment& DerivationExpression_ReturnProgram::assignments(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ReturnProgram.assignments)
  return _internal_assignments().Get(index);
}
inline ::substrait::DerivationExpression_ReturnProgram_Assignment* DerivationExpression_ReturnProgram::add_assignments() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::substrait::DerivationExpression_ReturnProgram_Assignment* _add = _internal_mutable_assignments()->Add();
  // @@protoc_insertion_point(field_add:substrait.DerivationExpression.ReturnProgram.assignments)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::DerivationExpression_ReturnProgram_Assignment>& DerivationExpression_ReturnProgram::assignments() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:substrait.DerivationExpression.ReturnProgram.assignments)
  return _internal_assignments();
}
inline const ::google::protobuf::RepeatedPtrField<::substrait::DerivationExpression_ReturnProgram_Assignment>&
DerivationExpression_ReturnProgram::_internal_assignments() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.assignments_;
}
inline ::google::protobuf::RepeatedPtrField<::substrait::DerivationExpression_ReturnProgram_Assignment>*
DerivationExpression_ReturnProgram::_internal_mutable_assignments() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.assignments_;
}

// .substrait.DerivationExpression final_expression = 2 [json_name = "finalExpression"];
inline bool DerivationExpression_ReturnProgram::has_final_expression() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.final_expression_ != nullptr);
  return value;
}
inline void DerivationExpression_ReturnProgram::clear_final_expression() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (_impl_.final_expression_ != nullptr) _impl_.final_expression_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::substrait::DerivationExpression& DerivationExpression_ReturnProgram::_internal_final_expression() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::substrait::DerivationExpression* p = _impl_.final_expression_;
  return p != nullptr ? *p : reinterpret_cast<const ::substrait::DerivationExpression&>(::substrait::_DerivationExpression_default_instance_);
}
inline const ::substrait::DerivationExpression& DerivationExpression_ReturnProgram::final_expression() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.ReturnProgram.final_expression)
  return _internal_final_expression();
}
inline void DerivationExpression_ReturnProgram::unsafe_arena_set_allocated_final_expression(::substrait::DerivationExpression* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.final_expression_);
  }
  _impl_.final_expression_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.ReturnProgram.final_expression)
}
inline ::substrait::DerivationExpression* DerivationExpression_ReturnProgram::release_final_expression() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* released = _impl_.final_expression_;
  _impl_.final_expression_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::substrait::DerivationExpression* DerivationExpression_ReturnProgram::unsafe_arena_release_final_expression() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.ReturnProgram.final_expression)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::substrait::DerivationExpression* temp = _impl_.final_expression_;
  _impl_.final_expression_ = nullptr;
  return temp;
}
inline ::substrait::DerivationExpression* DerivationExpression_ReturnProgram::_internal_mutable_final_expression() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.final_expression_ == nullptr) {
    auto* p = CreateMaybeMessage<::substrait::DerivationExpression>(GetArena());
    _impl_.final_expression_ = reinterpret_cast<::substrait::DerivationExpression*>(p);
  }
  return _impl_.final_expression_;
}
inline ::substrait::DerivationExpression* DerivationExpression_ReturnProgram::mutable_final_expression() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression* _msg = _internal_mutable_final_expression();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.ReturnProgram.final_expression)
  return _msg;
}
inline void DerivationExpression_ReturnProgram::set_allocated_final_expression(::substrait::DerivationExpression* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::substrait::DerivationExpression*>(_impl_.final_expression_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::substrait::DerivationExpression*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.final_expression_ = reinterpret_cast<::substrait::DerivationExpression*>(value);
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.ReturnProgram.final_expression)
}

// -------------------------------------------------------------------

// DerivationExpression

// .substrait.Type.Boolean bool = 1 [json_name = "bool"];
inline bool DerivationExpression::has_bool_() const {
  return kind_case() == kBool;
}
inline bool DerivationExpression::_internal_has_bool_() const {
  return kind_case() == kBool;
}
inline void DerivationExpression::set_has_bool_() {
  _impl_._oneof_case_[0] = kBool;
}
inline ::substrait::Type_Boolean* DerivationExpression::release_bool_() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.bool)
  if (kind_case() == kBool) {
    clear_has_kind();
    auto* temp = _impl_.kind_.bool__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Boolean& DerivationExpression::_internal_bool_() const {
  return kind_case() == kBool ? *_impl_.kind_.bool__ : reinterpret_cast<::substrait::Type_Boolean&>(::substrait::_Type_Boolean_default_instance_);
}
inline const ::substrait::Type_Boolean& DerivationExpression::bool_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.bool)
  return _internal_bool_();
}
inline ::substrait::Type_Boolean* DerivationExpression::unsafe_arena_release_bool_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.bool)
  if (kind_case() == kBool) {
    clear_has_kind();
    auto* temp = _impl_.kind_.bool__;
    _impl_.kind_.bool__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_bool_(::substrait::Type_Boolean* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_bool_();
    _impl_.kind_.bool__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.bool)
}
inline ::substrait::Type_Boolean* DerivationExpression::_internal_mutable_bool_() {
  if (kind_case() != kBool) {
    clear_kind();
    set_has_bool_();
    _impl_.kind_.bool__ = CreateMaybeMessage<::substrait::Type_Boolean>(GetArena());
  }
  return _impl_.kind_.bool__;
}
inline ::substrait::Type_Boolean* DerivationExpression::mutable_bool_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_Boolean* _msg = _internal_mutable_bool_();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.bool)
  return _msg;
}

// .substrait.Type.I8 i8 = 2 [json_name = "i8"];
inline bool DerivationExpression::has_i8() const {
  return kind_case() == kI8;
}
inline bool DerivationExpression::_internal_has_i8() const {
  return kind_case() == kI8;
}
inline void DerivationExpression::set_has_i8() {
  _impl_._oneof_case_[0] = kI8;
}
inline ::substrait::Type_I8* DerivationExpression::release_i8() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.i8)
  if (kind_case() == kI8) {
    clear_has_kind();
    auto* temp = _impl_.kind_.i8_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.i8_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_I8& DerivationExpression::_internal_i8() const {
  return kind_case() == kI8 ? *_impl_.kind_.i8_ : reinterpret_cast<::substrait::Type_I8&>(::substrait::_Type_I8_default_instance_);
}
inline const ::substrait::Type_I8& DerivationExpression::i8() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.i8)
  return _internal_i8();
}
inline ::substrait::Type_I8* DerivationExpression::unsafe_arena_release_i8() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.i8)
  if (kind_case() == kI8) {
    clear_has_kind();
    auto* temp = _impl_.kind_.i8_;
    _impl_.kind_.i8_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_i8(::substrait::Type_I8* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_i8();
    _impl_.kind_.i8_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.i8)
}
inline ::substrait::Type_I8* DerivationExpression::_internal_mutable_i8() {
  if (kind_case() != kI8) {
    clear_kind();
    set_has_i8();
    _impl_.kind_.i8_ = CreateMaybeMessage<::substrait::Type_I8>(GetArena());
  }
  return _impl_.kind_.i8_;
}
inline ::substrait::Type_I8* DerivationExpression::mutable_i8() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_I8* _msg = _internal_mutable_i8();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.i8)
  return _msg;
}

// .substrait.Type.I16 i16 = 3 [json_name = "i16"];
inline bool DerivationExpression::has_i16() const {
  return kind_case() == kI16;
}
inline bool DerivationExpression::_internal_has_i16() const {
  return kind_case() == kI16;
}
inline void DerivationExpression::set_has_i16() {
  _impl_._oneof_case_[0] = kI16;
}
inline ::substrait::Type_I16* DerivationExpression::release_i16() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.i16)
  if (kind_case() == kI16) {
    clear_has_kind();
    auto* temp = _impl_.kind_.i16_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.i16_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_I16& DerivationExpression::_internal_i16() const {
  return kind_case() == kI16 ? *_impl_.kind_.i16_ : reinterpret_cast<::substrait::Type_I16&>(::substrait::_Type_I16_default_instance_);
}
inline const ::substrait::Type_I16& DerivationExpression::i16() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.i16)
  return _internal_i16();
}
inline ::substrait::Type_I16* DerivationExpression::unsafe_arena_release_i16() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.i16)
  if (kind_case() == kI16) {
    clear_has_kind();
    auto* temp = _impl_.kind_.i16_;
    _impl_.kind_.i16_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_i16(::substrait::Type_I16* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_i16();
    _impl_.kind_.i16_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.i16)
}
inline ::substrait::Type_I16* DerivationExpression::_internal_mutable_i16() {
  if (kind_case() != kI16) {
    clear_kind();
    set_has_i16();
    _impl_.kind_.i16_ = CreateMaybeMessage<::substrait::Type_I16>(GetArena());
  }
  return _impl_.kind_.i16_;
}
inline ::substrait::Type_I16* DerivationExpression::mutable_i16() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_I16* _msg = _internal_mutable_i16();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.i16)
  return _msg;
}

// .substrait.Type.I32 i32 = 5 [json_name = "i32"];
inline bool DerivationExpression::has_i32() const {
  return kind_case() == kI32;
}
inline bool DerivationExpression::_internal_has_i32() const {
  return kind_case() == kI32;
}
inline void DerivationExpression::set_has_i32() {
  _impl_._oneof_case_[0] = kI32;
}
inline ::substrait::Type_I32* DerivationExpression::release_i32() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.i32)
  if (kind_case() == kI32) {
    clear_has_kind();
    auto* temp = _impl_.kind_.i32_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.i32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_I32& DerivationExpression::_internal_i32() const {
  return kind_case() == kI32 ? *_impl_.kind_.i32_ : reinterpret_cast<::substrait::Type_I32&>(::substrait::_Type_I32_default_instance_);
}
inline const ::substrait::Type_I32& DerivationExpression::i32() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.i32)
  return _internal_i32();
}
inline ::substrait::Type_I32* DerivationExpression::unsafe_arena_release_i32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.i32)
  if (kind_case() == kI32) {
    clear_has_kind();
    auto* temp = _impl_.kind_.i32_;
    _impl_.kind_.i32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_i32(::substrait::Type_I32* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_i32();
    _impl_.kind_.i32_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.i32)
}
inline ::substrait::Type_I32* DerivationExpression::_internal_mutable_i32() {
  if (kind_case() != kI32) {
    clear_kind();
    set_has_i32();
    _impl_.kind_.i32_ = CreateMaybeMessage<::substrait::Type_I32>(GetArena());
  }
  return _impl_.kind_.i32_;
}
inline ::substrait::Type_I32* DerivationExpression::mutable_i32() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_I32* _msg = _internal_mutable_i32();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.i32)
  return _msg;
}

// .substrait.Type.I64 i64 = 7 [json_name = "i64"];
inline bool DerivationExpression::has_i64() const {
  return kind_case() == kI64;
}
inline bool DerivationExpression::_internal_has_i64() const {
  return kind_case() == kI64;
}
inline void DerivationExpression::set_has_i64() {
  _impl_._oneof_case_[0] = kI64;
}
inline ::substrait::Type_I64* DerivationExpression::release_i64() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.i64)
  if (kind_case() == kI64) {
    clear_has_kind();
    auto* temp = _impl_.kind_.i64_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.i64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_I64& DerivationExpression::_internal_i64() const {
  return kind_case() == kI64 ? *_impl_.kind_.i64_ : reinterpret_cast<::substrait::Type_I64&>(::substrait::_Type_I64_default_instance_);
}
inline const ::substrait::Type_I64& DerivationExpression::i64() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.i64)
  return _internal_i64();
}
inline ::substrait::Type_I64* DerivationExpression::unsafe_arena_release_i64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.i64)
  if (kind_case() == kI64) {
    clear_has_kind();
    auto* temp = _impl_.kind_.i64_;
    _impl_.kind_.i64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_i64(::substrait::Type_I64* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_i64();
    _impl_.kind_.i64_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.i64)
}
inline ::substrait::Type_I64* DerivationExpression::_internal_mutable_i64() {
  if (kind_case() != kI64) {
    clear_kind();
    set_has_i64();
    _impl_.kind_.i64_ = CreateMaybeMessage<::substrait::Type_I64>(GetArena());
  }
  return _impl_.kind_.i64_;
}
inline ::substrait::Type_I64* DerivationExpression::mutable_i64() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_I64* _msg = _internal_mutable_i64();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.i64)
  return _msg;
}

// .substrait.Type.FP32 fp32 = 10 [json_name = "fp32"];
inline bool DerivationExpression::has_fp32() const {
  return kind_case() == kFp32;
}
inline bool DerivationExpression::_internal_has_fp32() const {
  return kind_case() == kFp32;
}
inline void DerivationExpression::set_has_fp32() {
  _impl_._oneof_case_[0] = kFp32;
}
inline ::substrait::Type_FP32* DerivationExpression::release_fp32() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.fp32)
  if (kind_case() == kFp32) {
    clear_has_kind();
    auto* temp = _impl_.kind_.fp32_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.fp32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_FP32& DerivationExpression::_internal_fp32() const {
  return kind_case() == kFp32 ? *_impl_.kind_.fp32_ : reinterpret_cast<::substrait::Type_FP32&>(::substrait::_Type_FP32_default_instance_);
}
inline const ::substrait::Type_FP32& DerivationExpression::fp32() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.fp32)
  return _internal_fp32();
}
inline ::substrait::Type_FP32* DerivationExpression::unsafe_arena_release_fp32() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.fp32)
  if (kind_case() == kFp32) {
    clear_has_kind();
    auto* temp = _impl_.kind_.fp32_;
    _impl_.kind_.fp32_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_fp32(::substrait::Type_FP32* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_fp32();
    _impl_.kind_.fp32_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.fp32)
}
inline ::substrait::Type_FP32* DerivationExpression::_internal_mutable_fp32() {
  if (kind_case() != kFp32) {
    clear_kind();
    set_has_fp32();
    _impl_.kind_.fp32_ = CreateMaybeMessage<::substrait::Type_FP32>(GetArena());
  }
  return _impl_.kind_.fp32_;
}
inline ::substrait::Type_FP32* DerivationExpression::mutable_fp32() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_FP32* _msg = _internal_mutable_fp32();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.fp32)
  return _msg;
}

// .substrait.Type.FP64 fp64 = 11 [json_name = "fp64"];
inline bool DerivationExpression::has_fp64() const {
  return kind_case() == kFp64;
}
inline bool DerivationExpression::_internal_has_fp64() const {
  return kind_case() == kFp64;
}
inline void DerivationExpression::set_has_fp64() {
  _impl_._oneof_case_[0] = kFp64;
}
inline ::substrait::Type_FP64* DerivationExpression::release_fp64() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.fp64)
  if (kind_case() == kFp64) {
    clear_has_kind();
    auto* temp = _impl_.kind_.fp64_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.fp64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_FP64& DerivationExpression::_internal_fp64() const {
  return kind_case() == kFp64 ? *_impl_.kind_.fp64_ : reinterpret_cast<::substrait::Type_FP64&>(::substrait::_Type_FP64_default_instance_);
}
inline const ::substrait::Type_FP64& DerivationExpression::fp64() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.fp64)
  return _internal_fp64();
}
inline ::substrait::Type_FP64* DerivationExpression::unsafe_arena_release_fp64() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.fp64)
  if (kind_case() == kFp64) {
    clear_has_kind();
    auto* temp = _impl_.kind_.fp64_;
    _impl_.kind_.fp64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_fp64(::substrait::Type_FP64* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_fp64();
    _impl_.kind_.fp64_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.fp64)
}
inline ::substrait::Type_FP64* DerivationExpression::_internal_mutable_fp64() {
  if (kind_case() != kFp64) {
    clear_kind();
    set_has_fp64();
    _impl_.kind_.fp64_ = CreateMaybeMessage<::substrait::Type_FP64>(GetArena());
  }
  return _impl_.kind_.fp64_;
}
inline ::substrait::Type_FP64* DerivationExpression::mutable_fp64() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_FP64* _msg = _internal_mutable_fp64();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.fp64)
  return _msg;
}

// .substrait.Type.String string = 12 [json_name = "string"];
inline bool DerivationExpression::has_string() const {
  return kind_case() == kString;
}
inline bool DerivationExpression::_internal_has_string() const {
  return kind_case() == kString;
}
inline void DerivationExpression::set_has_string() {
  _impl_._oneof_case_[0] = kString;
}
inline ::substrait::Type_String* DerivationExpression::release_string() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.string)
  if (kind_case() == kString) {
    clear_has_kind();
    auto* temp = _impl_.kind_.string_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_String& DerivationExpression::_internal_string() const {
  return kind_case() == kString ? *_impl_.kind_.string_ : reinterpret_cast<::substrait::Type_String&>(::substrait::_Type_String_default_instance_);
}
inline const ::substrait::Type_String& DerivationExpression::string() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.string)
  return _internal_string();
}
inline ::substrait::Type_String* DerivationExpression::unsafe_arena_release_string() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.string)
  if (kind_case() == kString) {
    clear_has_kind();
    auto* temp = _impl_.kind_.string_;
    _impl_.kind_.string_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_string(::substrait::Type_String* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_string();
    _impl_.kind_.string_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.string)
}
inline ::substrait::Type_String* DerivationExpression::_internal_mutable_string() {
  if (kind_case() != kString) {
    clear_kind();
    set_has_string();
    _impl_.kind_.string_ = CreateMaybeMessage<::substrait::Type_String>(GetArena());
  }
  return _impl_.kind_.string_;
}
inline ::substrait::Type_String* DerivationExpression::mutable_string() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_String* _msg = _internal_mutable_string();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.string)
  return _msg;
}

// .substrait.Type.Binary binary = 13 [json_name = "binary"];
inline bool DerivationExpression::has_binary() const {
  return kind_case() == kBinary;
}
inline bool DerivationExpression::_internal_has_binary() const {
  return kind_case() == kBinary;
}
inline void DerivationExpression::set_has_binary() {
  _impl_._oneof_case_[0] = kBinary;
}
inline ::substrait::Type_Binary* DerivationExpression::release_binary() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.binary)
  if (kind_case() == kBinary) {
    clear_has_kind();
    auto* temp = _impl_.kind_.binary_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Binary& DerivationExpression::_internal_binary() const {
  return kind_case() == kBinary ? *_impl_.kind_.binary_ : reinterpret_cast<::substrait::Type_Binary&>(::substrait::_Type_Binary_default_instance_);
}
inline const ::substrait::Type_Binary& DerivationExpression::binary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.binary)
  return _internal_binary();
}
inline ::substrait::Type_Binary* DerivationExpression::unsafe_arena_release_binary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.binary)
  if (kind_case() == kBinary) {
    clear_has_kind();
    auto* temp = _impl_.kind_.binary_;
    _impl_.kind_.binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_binary(::substrait::Type_Binary* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_binary();
    _impl_.kind_.binary_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.binary)
}
inline ::substrait::Type_Binary* DerivationExpression::_internal_mutable_binary() {
  if (kind_case() != kBinary) {
    clear_kind();
    set_has_binary();
    _impl_.kind_.binary_ = CreateMaybeMessage<::substrait::Type_Binary>(GetArena());
  }
  return _impl_.kind_.binary_;
}
inline ::substrait::Type_Binary* DerivationExpression::mutable_binary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_Binary* _msg = _internal_mutable_binary();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.binary)
  return _msg;
}

// .substrait.Type.Timestamp timestamp = 14 [json_name = "timestamp"];
inline bool DerivationExpression::has_timestamp() const {
  return kind_case() == kTimestamp;
}
inline bool DerivationExpression::_internal_has_timestamp() const {
  return kind_case() == kTimestamp;
}
inline void DerivationExpression::set_has_timestamp() {
  _impl_._oneof_case_[0] = kTimestamp;
}
inline ::substrait::Type_Timestamp* DerivationExpression::release_timestamp() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.timestamp)
  if (kind_case() == kTimestamp) {
    clear_has_kind();
    auto* temp = _impl_.kind_.timestamp_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Timestamp& DerivationExpression::_internal_timestamp() const {
  return kind_case() == kTimestamp ? *_impl_.kind_.timestamp_ : reinterpret_cast<::substrait::Type_Timestamp&>(::substrait::_Type_Timestamp_default_instance_);
}
inline const ::substrait::Type_Timestamp& DerivationExpression::timestamp() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.timestamp)
  return _internal_timestamp();
}
inline ::substrait::Type_Timestamp* DerivationExpression::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.timestamp)
  if (kind_case() == kTimestamp) {
    clear_has_kind();
    auto* temp = _impl_.kind_.timestamp_;
    _impl_.kind_.timestamp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_timestamp(::substrait::Type_Timestamp* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_timestamp();
    _impl_.kind_.timestamp_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.timestamp)
}
inline ::substrait::Type_Timestamp* DerivationExpression::_internal_mutable_timestamp() {
  if (kind_case() != kTimestamp) {
    clear_kind();
    set_has_timestamp();
    _impl_.kind_.timestamp_ = CreateMaybeMessage<::substrait::Type_Timestamp>(GetArena());
  }
  return _impl_.kind_.timestamp_;
}
inline ::substrait::Type_Timestamp* DerivationExpression::mutable_timestamp() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.timestamp)
  return _msg;
}

// .substrait.Type.Date date = 16 [json_name = "date"];
inline bool DerivationExpression::has_date() const {
  return kind_case() == kDate;
}
inline bool DerivationExpression::_internal_has_date() const {
  return kind_case() == kDate;
}
inline void DerivationExpression::set_has_date() {
  _impl_._oneof_case_[0] = kDate;
}
inline ::substrait::Type_Date* DerivationExpression::release_date() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.date)
  if (kind_case() == kDate) {
    clear_has_kind();
    auto* temp = _impl_.kind_.date_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.date_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Date& DerivationExpression::_internal_date() const {
  return kind_case() == kDate ? *_impl_.kind_.date_ : reinterpret_cast<::substrait::Type_Date&>(::substrait::_Type_Date_default_instance_);
}
inline const ::substrait::Type_Date& DerivationExpression::date() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.date)
  return _internal_date();
}
inline ::substrait::Type_Date* DerivationExpression::unsafe_arena_release_date() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.date)
  if (kind_case() == kDate) {
    clear_has_kind();
    auto* temp = _impl_.kind_.date_;
    _impl_.kind_.date_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_date(::substrait::Type_Date* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_date();
    _impl_.kind_.date_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.date)
}
inline ::substrait::Type_Date* DerivationExpression::_internal_mutable_date() {
  if (kind_case() != kDate) {
    clear_kind();
    set_has_date();
    _impl_.kind_.date_ = CreateMaybeMessage<::substrait::Type_Date>(GetArena());
  }
  return _impl_.kind_.date_;
}
inline ::substrait::Type_Date* DerivationExpression::mutable_date() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_Date* _msg = _internal_mutable_date();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.date)
  return _msg;
}

// .substrait.Type.Time time = 17 [json_name = "time"];
inline bool DerivationExpression::has_time() const {
  return kind_case() == kTime;
}
inline bool DerivationExpression::_internal_has_time() const {
  return kind_case() == kTime;
}
inline void DerivationExpression::set_has_time() {
  _impl_._oneof_case_[0] = kTime;
}
inline ::substrait::Type_Time* DerivationExpression::release_time() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.time)
  if (kind_case() == kTime) {
    clear_has_kind();
    auto* temp = _impl_.kind_.time_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_Time& DerivationExpression::_internal_time() const {
  return kind_case() == kTime ? *_impl_.kind_.time_ : reinterpret_cast<::substrait::Type_Time&>(::substrait::_Type_Time_default_instance_);
}
inline const ::substrait::Type_Time& DerivationExpression::time() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.time)
  return _internal_time();
}
inline ::substrait::Type_Time* DerivationExpression::unsafe_arena_release_time() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.time)
  if (kind_case() == kTime) {
    clear_has_kind();
    auto* temp = _impl_.kind_.time_;
    _impl_.kind_.time_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_time(::substrait::Type_Time* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_time();
    _impl_.kind_.time_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.time)
}
inline ::substrait::Type_Time* DerivationExpression::_internal_mutable_time() {
  if (kind_case() != kTime) {
    clear_kind();
    set_has_time();
    _impl_.kind_.time_ = CreateMaybeMessage<::substrait::Type_Time>(GetArena());
  }
  return _impl_.kind_.time_;
}
inline ::substrait::Type_Time* DerivationExpression::mutable_time() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_Time* _msg = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.time)
  return _msg;
}

// .substrait.Type.IntervalYear interval_year = 19 [json_name = "intervalYear"];
inline bool DerivationExpression::has_interval_year() const {
  return kind_case() == kIntervalYear;
}
inline bool DerivationExpression::_internal_has_interval_year() const {
  return kind_case() == kIntervalYear;
}
inline void DerivationExpression::set_has_interval_year() {
  _impl_._oneof_case_[0] = kIntervalYear;
}
inline ::substrait::Type_IntervalYear* DerivationExpression::release_interval_year() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.interval_year)
  if (kind_case() == kIntervalYear) {
    clear_has_kind();
    auto* temp = _impl_.kind_.interval_year_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.interval_year_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_IntervalYear& DerivationExpression::_internal_interval_year() const {
  return kind_case() == kIntervalYear ? *_impl_.kind_.interval_year_ : reinterpret_cast<::substrait::Type_IntervalYear&>(::substrait::_Type_IntervalYear_default_instance_);
}
inline const ::substrait::Type_IntervalYear& DerivationExpression::interval_year() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.interval_year)
  return _internal_interval_year();
}
inline ::substrait::Type_IntervalYear* DerivationExpression::unsafe_arena_release_interval_year() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.interval_year)
  if (kind_case() == kIntervalYear) {
    clear_has_kind();
    auto* temp = _impl_.kind_.interval_year_;
    _impl_.kind_.interval_year_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_interval_year(::substrait::Type_IntervalYear* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_interval_year();
    _impl_.kind_.interval_year_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.interval_year)
}
inline ::substrait::Type_IntervalYear* DerivationExpression::_internal_mutable_interval_year() {
  if (kind_case() != kIntervalYear) {
    clear_kind();
    set_has_interval_year();
    _impl_.kind_.interval_year_ = CreateMaybeMessage<::substrait::Type_IntervalYear>(GetArena());
  }
  return _impl_.kind_.interval_year_;
}
inline ::substrait::Type_IntervalYear* DerivationExpression::mutable_interval_year() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_IntervalYear* _msg = _internal_mutable_interval_year();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.interval_year)
  return _msg;
}

// .substrait.Type.IntervalDay interval_day = 20 [json_name = "intervalDay"];
inline bool DerivationExpression::has_interval_day() const {
  return kind_case() == kIntervalDay;
}
inline bool DerivationExpression::_internal_has_interval_day() const {
  return kind_case() == kIntervalDay;
}
inline void DerivationExpression::set_has_interval_day() {
  _impl_._oneof_case_[0] = kIntervalDay;
}
inline ::substrait::Type_IntervalDay* DerivationExpression::release_interval_day() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.interval_day)
  if (kind_case() == kIntervalDay) {
    clear_has_kind();
    auto* temp = _impl_.kind_.interval_day_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.interval_day_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_IntervalDay& DerivationExpression::_internal_interval_day() const {
  return kind_case() == kIntervalDay ? *_impl_.kind_.interval_day_ : reinterpret_cast<::substrait::Type_IntervalDay&>(::substrait::_Type_IntervalDay_default_instance_);
}
inline const ::substrait::Type_IntervalDay& DerivationExpression::interval_day() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.interval_day)
  return _internal_interval_day();
}
inline ::substrait::Type_IntervalDay* DerivationExpression::unsafe_arena_release_interval_day() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.interval_day)
  if (kind_case() == kIntervalDay) {
    clear_has_kind();
    auto* temp = _impl_.kind_.interval_day_;
    _impl_.kind_.interval_day_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_interval_day(::substrait::Type_IntervalDay* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_interval_day();
    _impl_.kind_.interval_day_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.interval_day)
}
inline ::substrait::Type_IntervalDay* DerivationExpression::_internal_mutable_interval_day() {
  if (kind_case() != kIntervalDay) {
    clear_kind();
    set_has_interval_day();
    _impl_.kind_.interval_day_ = CreateMaybeMessage<::substrait::Type_IntervalDay>(GetArena());
  }
  return _impl_.kind_.interval_day_;
}
inline ::substrait::Type_IntervalDay* DerivationExpression::mutable_interval_day() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_IntervalDay* _msg = _internal_mutable_interval_day();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.interval_day)
  return _msg;
}

// .substrait.Type.TimestampTZ timestamp_tz = 29 [json_name = "timestampTz"];
inline bool DerivationExpression::has_timestamp_tz() const {
  return kind_case() == kTimestampTz;
}
inline bool DerivationExpression::_internal_has_timestamp_tz() const {
  return kind_case() == kTimestampTz;
}
inline void DerivationExpression::set_has_timestamp_tz() {
  _impl_._oneof_case_[0] = kTimestampTz;
}
inline ::substrait::Type_TimestampTZ* DerivationExpression::release_timestamp_tz() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.timestamp_tz)
  if (kind_case() == kTimestampTz) {
    clear_has_kind();
    auto* temp = _impl_.kind_.timestamp_tz_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.timestamp_tz_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_TimestampTZ& DerivationExpression::_internal_timestamp_tz() const {
  return kind_case() == kTimestampTz ? *_impl_.kind_.timestamp_tz_ : reinterpret_cast<::substrait::Type_TimestampTZ&>(::substrait::_Type_TimestampTZ_default_instance_);
}
inline const ::substrait::Type_TimestampTZ& DerivationExpression::timestamp_tz() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.timestamp_tz)
  return _internal_timestamp_tz();
}
inline ::substrait::Type_TimestampTZ* DerivationExpression::unsafe_arena_release_timestamp_tz() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.timestamp_tz)
  if (kind_case() == kTimestampTz) {
    clear_has_kind();
    auto* temp = _impl_.kind_.timestamp_tz_;
    _impl_.kind_.timestamp_tz_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_timestamp_tz(::substrait::Type_TimestampTZ* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_timestamp_tz();
    _impl_.kind_.timestamp_tz_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.timestamp_tz)
}
inline ::substrait::Type_TimestampTZ* DerivationExpression::_internal_mutable_timestamp_tz() {
  if (kind_case() != kTimestampTz) {
    clear_kind();
    set_has_timestamp_tz();
    _impl_.kind_.timestamp_tz_ = CreateMaybeMessage<::substrait::Type_TimestampTZ>(GetArena());
  }
  return _impl_.kind_.timestamp_tz_;
}
inline ::substrait::Type_TimestampTZ* DerivationExpression::mutable_timestamp_tz() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_TimestampTZ* _msg = _internal_mutable_timestamp_tz();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.timestamp_tz)
  return _msg;
}

// .substrait.Type.UUID uuid = 32 [json_name = "uuid"];
inline bool DerivationExpression::has_uuid() const {
  return kind_case() == kUuid;
}
inline bool DerivationExpression::_internal_has_uuid() const {
  return kind_case() == kUuid;
}
inline void DerivationExpression::set_has_uuid() {
  _impl_._oneof_case_[0] = kUuid;
}
inline ::substrait::Type_UUID* DerivationExpression::release_uuid() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.uuid)
  if (kind_case() == kUuid) {
    clear_has_kind();
    auto* temp = _impl_.kind_.uuid_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.uuid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::Type_UUID& DerivationExpression::_internal_uuid() const {
  return kind_case() == kUuid ? *_impl_.kind_.uuid_ : reinterpret_cast<::substrait::Type_UUID&>(::substrait::_Type_UUID_default_instance_);
}
inline const ::substrait::Type_UUID& DerivationExpression::uuid() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.uuid)
  return _internal_uuid();
}
inline ::substrait::Type_UUID* DerivationExpression::unsafe_arena_release_uuid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.uuid)
  if (kind_case() == kUuid) {
    clear_has_kind();
    auto* temp = _impl_.kind_.uuid_;
    _impl_.kind_.uuid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_uuid(::substrait::Type_UUID* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_uuid();
    _impl_.kind_.uuid_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.uuid)
}
inline ::substrait::Type_UUID* DerivationExpression::_internal_mutable_uuid() {
  if (kind_case() != kUuid) {
    clear_kind();
    set_has_uuid();
    _impl_.kind_.uuid_ = CreateMaybeMessage<::substrait::Type_UUID>(GetArena());
  }
  return _impl_.kind_.uuid_;
}
inline ::substrait::Type_UUID* DerivationExpression::mutable_uuid() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::Type_UUID* _msg = _internal_mutable_uuid();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.uuid)
  return _msg;
}

// .substrait.DerivationExpression.ExpressionFixedChar fixed_char = 21 [json_name = "fixedChar"];
inline bool DerivationExpression::has_fixed_char() const {
  return kind_case() == kFixedChar;
}
inline bool DerivationExpression::_internal_has_fixed_char() const {
  return kind_case() == kFixedChar;
}
inline void DerivationExpression::set_has_fixed_char() {
  _impl_._oneof_case_[0] = kFixedChar;
}
inline void DerivationExpression::clear_fixed_char() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kFixedChar) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.fixed_char_;
    }
    clear_has_kind();
  }
}
inline ::substrait::DerivationExpression_ExpressionFixedChar* DerivationExpression::release_fixed_char() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.fixed_char)
  if (kind_case() == kFixedChar) {
    clear_has_kind();
    auto* temp = _impl_.kind_.fixed_char_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.fixed_char_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::DerivationExpression_ExpressionFixedChar& DerivationExpression::_internal_fixed_char() const {
  return kind_case() == kFixedChar ? *_impl_.kind_.fixed_char_ : reinterpret_cast<::substrait::DerivationExpression_ExpressionFixedChar&>(::substrait::_DerivationExpression_ExpressionFixedChar_default_instance_);
}
inline const ::substrait::DerivationExpression_ExpressionFixedChar& DerivationExpression::fixed_char() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.fixed_char)
  return _internal_fixed_char();
}
inline ::substrait::DerivationExpression_ExpressionFixedChar* DerivationExpression::unsafe_arena_release_fixed_char() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.fixed_char)
  if (kind_case() == kFixedChar) {
    clear_has_kind();
    auto* temp = _impl_.kind_.fixed_char_;
    _impl_.kind_.fixed_char_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_fixed_char(::substrait::DerivationExpression_ExpressionFixedChar* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_fixed_char();
    _impl_.kind_.fixed_char_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.fixed_char)
}
inline ::substrait::DerivationExpression_ExpressionFixedChar* DerivationExpression::_internal_mutable_fixed_char() {
  if (kind_case() != kFixedChar) {
    clear_kind();
    set_has_fixed_char();
    _impl_.kind_.fixed_char_ = CreateMaybeMessage<::substrait::DerivationExpression_ExpressionFixedChar>(GetArena());
  }
  return _impl_.kind_.fixed_char_;
}
inline ::substrait::DerivationExpression_ExpressionFixedChar* DerivationExpression::mutable_fixed_char() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression_ExpressionFixedChar* _msg = _internal_mutable_fixed_char();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.fixed_char)
  return _msg;
}

// .substrait.DerivationExpression.ExpressionVarChar varchar = 22 [json_name = "varchar"];
inline bool DerivationExpression::has_varchar() const {
  return kind_case() == kVarchar;
}
inline bool DerivationExpression::_internal_has_varchar() const {
  return kind_case() == kVarchar;
}
inline void DerivationExpression::set_has_varchar() {
  _impl_._oneof_case_[0] = kVarchar;
}
inline void DerivationExpression::clear_varchar() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kVarchar) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.varchar_;
    }
    clear_has_kind();
  }
}
inline ::substrait::DerivationExpression_ExpressionVarChar* DerivationExpression::release_varchar() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.varchar)
  if (kind_case() == kVarchar) {
    clear_has_kind();
    auto* temp = _impl_.kind_.varchar_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.varchar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::DerivationExpression_ExpressionVarChar& DerivationExpression::_internal_varchar() const {
  return kind_case() == kVarchar ? *_impl_.kind_.varchar_ : reinterpret_cast<::substrait::DerivationExpression_ExpressionVarChar&>(::substrait::_DerivationExpression_ExpressionVarChar_default_instance_);
}
inline const ::substrait::DerivationExpression_ExpressionVarChar& DerivationExpression::varchar() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.varchar)
  return _internal_varchar();
}
inline ::substrait::DerivationExpression_ExpressionVarChar* DerivationExpression::unsafe_arena_release_varchar() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.varchar)
  if (kind_case() == kVarchar) {
    clear_has_kind();
    auto* temp = _impl_.kind_.varchar_;
    _impl_.kind_.varchar_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_varchar(::substrait::DerivationExpression_ExpressionVarChar* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_varchar();
    _impl_.kind_.varchar_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.varchar)
}
inline ::substrait::DerivationExpression_ExpressionVarChar* DerivationExpression::_internal_mutable_varchar() {
  if (kind_case() != kVarchar) {
    clear_kind();
    set_has_varchar();
    _impl_.kind_.varchar_ = CreateMaybeMessage<::substrait::DerivationExpression_ExpressionVarChar>(GetArena());
  }
  return _impl_.kind_.varchar_;
}
inline ::substrait::DerivationExpression_ExpressionVarChar* DerivationExpression::mutable_varchar() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression_ExpressionVarChar* _msg = _internal_mutable_varchar();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.varchar)
  return _msg;
}

// .substrait.DerivationExpression.ExpressionFixedBinary fixed_binary = 23 [json_name = "fixedBinary"];
inline bool DerivationExpression::has_fixed_binary() const {
  return kind_case() == kFixedBinary;
}
inline bool DerivationExpression::_internal_has_fixed_binary() const {
  return kind_case() == kFixedBinary;
}
inline void DerivationExpression::set_has_fixed_binary() {
  _impl_._oneof_case_[0] = kFixedBinary;
}
inline void DerivationExpression::clear_fixed_binary() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kFixedBinary) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.fixed_binary_;
    }
    clear_has_kind();
  }
}
inline ::substrait::DerivationExpression_ExpressionFixedBinary* DerivationExpression::release_fixed_binary() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.fixed_binary)
  if (kind_case() == kFixedBinary) {
    clear_has_kind();
    auto* temp = _impl_.kind_.fixed_binary_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.fixed_binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::DerivationExpression_ExpressionFixedBinary& DerivationExpression::_internal_fixed_binary() const {
  return kind_case() == kFixedBinary ? *_impl_.kind_.fixed_binary_ : reinterpret_cast<::substrait::DerivationExpression_ExpressionFixedBinary&>(::substrait::_DerivationExpression_ExpressionFixedBinary_default_instance_);
}
inline const ::substrait::DerivationExpression_ExpressionFixedBinary& DerivationExpression::fixed_binary() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.fixed_binary)
  return _internal_fixed_binary();
}
inline ::substrait::DerivationExpression_ExpressionFixedBinary* DerivationExpression::unsafe_arena_release_fixed_binary() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.fixed_binary)
  if (kind_case() == kFixedBinary) {
    clear_has_kind();
    auto* temp = _impl_.kind_.fixed_binary_;
    _impl_.kind_.fixed_binary_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_fixed_binary(::substrait::DerivationExpression_ExpressionFixedBinary* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_fixed_binary();
    _impl_.kind_.fixed_binary_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.fixed_binary)
}
inline ::substrait::DerivationExpression_ExpressionFixedBinary* DerivationExpression::_internal_mutable_fixed_binary() {
  if (kind_case() != kFixedBinary) {
    clear_kind();
    set_has_fixed_binary();
    _impl_.kind_.fixed_binary_ = CreateMaybeMessage<::substrait::DerivationExpression_ExpressionFixedBinary>(GetArena());
  }
  return _impl_.kind_.fixed_binary_;
}
inline ::substrait::DerivationExpression_ExpressionFixedBinary* DerivationExpression::mutable_fixed_binary() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression_ExpressionFixedBinary* _msg = _internal_mutable_fixed_binary();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.fixed_binary)
  return _msg;
}

// .substrait.DerivationExpression.ExpressionDecimal decimal = 24 [json_name = "decimal"];
inline bool DerivationExpression::has_decimal() const {
  return kind_case() == kDecimal;
}
inline bool DerivationExpression::_internal_has_decimal() const {
  return kind_case() == kDecimal;
}
inline void DerivationExpression::set_has_decimal() {
  _impl_._oneof_case_[0] = kDecimal;
}
inline void DerivationExpression::clear_decimal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kDecimal) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.decimal_;
    }
    clear_has_kind();
  }
}
inline ::substrait::DerivationExpression_ExpressionDecimal* DerivationExpression::release_decimal() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.decimal)
  if (kind_case() == kDecimal) {
    clear_has_kind();
    auto* temp = _impl_.kind_.decimal_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.decimal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::DerivationExpression_ExpressionDecimal& DerivationExpression::_internal_decimal() const {
  return kind_case() == kDecimal ? *_impl_.kind_.decimal_ : reinterpret_cast<::substrait::DerivationExpression_ExpressionDecimal&>(::substrait::_DerivationExpression_ExpressionDecimal_default_instance_);
}
inline const ::substrait::DerivationExpression_ExpressionDecimal& DerivationExpression::decimal() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.decimal)
  return _internal_decimal();
}
inline ::substrait::DerivationExpression_ExpressionDecimal* DerivationExpression::unsafe_arena_release_decimal() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.decimal)
  if (kind_case() == kDecimal) {
    clear_has_kind();
    auto* temp = _impl_.kind_.decimal_;
    _impl_.kind_.decimal_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_decimal(::substrait::DerivationExpression_ExpressionDecimal* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_decimal();
    _impl_.kind_.decimal_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.decimal)
}
inline ::substrait::DerivationExpression_ExpressionDecimal* DerivationExpression::_internal_mutable_decimal() {
  if (kind_case() != kDecimal) {
    clear_kind();
    set_has_decimal();
    _impl_.kind_.decimal_ = CreateMaybeMessage<::substrait::DerivationExpression_ExpressionDecimal>(GetArena());
  }
  return _impl_.kind_.decimal_;
}
inline ::substrait::DerivationExpression_ExpressionDecimal* DerivationExpression::mutable_decimal() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression_ExpressionDecimal* _msg = _internal_mutable_decimal();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.decimal)
  return _msg;
}

// .substrait.DerivationExpression.ExpressionStruct struct = 25 [json_name = "struct"];
inline bool DerivationExpression::has_struct_() const {
  return kind_case() == kStruct;
}
inline bool DerivationExpression::_internal_has_struct_() const {
  return kind_case() == kStruct;
}
inline void DerivationExpression::set_has_struct_() {
  _impl_._oneof_case_[0] = kStruct;
}
inline void DerivationExpression::clear_struct_() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kStruct) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.struct__;
    }
    clear_has_kind();
  }
}
inline ::substrait::DerivationExpression_ExpressionStruct* DerivationExpression::release_struct_() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.struct)
  if (kind_case() == kStruct) {
    clear_has_kind();
    auto* temp = _impl_.kind_.struct__;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::DerivationExpression_ExpressionStruct& DerivationExpression::_internal_struct_() const {
  return kind_case() == kStruct ? *_impl_.kind_.struct__ : reinterpret_cast<::substrait::DerivationExpression_ExpressionStruct&>(::substrait::_DerivationExpression_ExpressionStruct_default_instance_);
}
inline const ::substrait::DerivationExpression_ExpressionStruct& DerivationExpression::struct_() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.struct)
  return _internal_struct_();
}
inline ::substrait::DerivationExpression_ExpressionStruct* DerivationExpression::unsafe_arena_release_struct_() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.struct)
  if (kind_case() == kStruct) {
    clear_has_kind();
    auto* temp = _impl_.kind_.struct__;
    _impl_.kind_.struct__ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_struct_(::substrait::DerivationExpression_ExpressionStruct* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_struct_();
    _impl_.kind_.struct__ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.struct)
}
inline ::substrait::DerivationExpression_ExpressionStruct* DerivationExpression::_internal_mutable_struct_() {
  if (kind_case() != kStruct) {
    clear_kind();
    set_has_struct_();
    _impl_.kind_.struct__ = CreateMaybeMessage<::substrait::DerivationExpression_ExpressionStruct>(GetArena());
  }
  return _impl_.kind_.struct__;
}
inline ::substrait::DerivationExpression_ExpressionStruct* DerivationExpression::mutable_struct_() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression_ExpressionStruct* _msg = _internal_mutable_struct_();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.struct)
  return _msg;
}

// .substrait.DerivationExpression.ExpressionList list = 27 [json_name = "list"];
inline bool DerivationExpression::has_list() const {
  return kind_case() == kList;
}
inline bool DerivationExpression::_internal_has_list() const {
  return kind_case() == kList;
}
inline void DerivationExpression::set_has_list() {
  _impl_._oneof_case_[0] = kList;
}
inline void DerivationExpression::clear_list() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kList) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.list_;
    }
    clear_has_kind();
  }
}
inline ::substrait::DerivationExpression_ExpressionList* DerivationExpression::release_list() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.list)
  if (kind_case() == kList) {
    clear_has_kind();
    auto* temp = _impl_.kind_.list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::DerivationExpression_ExpressionList& DerivationExpression::_internal_list() const {
  return kind_case() == kList ? *_impl_.kind_.list_ : reinterpret_cast<::substrait::DerivationExpression_ExpressionList&>(::substrait::_DerivationExpression_ExpressionList_default_instance_);
}
inline const ::substrait::DerivationExpression_ExpressionList& DerivationExpression::list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.list)
  return _internal_list();
}
inline ::substrait::DerivationExpression_ExpressionList* DerivationExpression::unsafe_arena_release_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.list)
  if (kind_case() == kList) {
    clear_has_kind();
    auto* temp = _impl_.kind_.list_;
    _impl_.kind_.list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_list(::substrait::DerivationExpression_ExpressionList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_list();
    _impl_.kind_.list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.list)
}
inline ::substrait::DerivationExpression_ExpressionList* DerivationExpression::_internal_mutable_list() {
  if (kind_case() != kList) {
    clear_kind();
    set_has_list();
    _impl_.kind_.list_ = CreateMaybeMessage<::substrait::DerivationExpression_ExpressionList>(GetArena());
  }
  return _impl_.kind_.list_;
}
inline ::substrait::DerivationExpression_ExpressionList* DerivationExpression::mutable_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression_ExpressionList* _msg = _internal_mutable_list();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.list)
  return _msg;
}

// .substrait.DerivationExpression.ExpressionMap map = 28 [json_name = "map"];
inline bool DerivationExpression::has_map() const {
  return kind_case() == kMap;
}
inline bool DerivationExpression::_internal_has_map() const {
  return kind_case() == kMap;
}
inline void DerivationExpression::set_has_map() {
  _impl_._oneof_case_[0] = kMap;
}
inline void DerivationExpression::clear_map() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kMap) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.map_;
    }
    clear_has_kind();
  }
}
inline ::substrait::DerivationExpression_ExpressionMap* DerivationExpression::release_map() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.map)
  if (kind_case() == kMap) {
    clear_has_kind();
    auto* temp = _impl_.kind_.map_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::DerivationExpression_ExpressionMap& DerivationExpression::_internal_map() const {
  return kind_case() == kMap ? *_impl_.kind_.map_ : reinterpret_cast<::substrait::DerivationExpression_ExpressionMap&>(::substrait::_DerivationExpression_ExpressionMap_default_instance_);
}
inline const ::substrait::DerivationExpression_ExpressionMap& DerivationExpression::map() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.map)
  return _internal_map();
}
inline ::substrait::DerivationExpression_ExpressionMap* DerivationExpression::unsafe_arena_release_map() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.map)
  if (kind_case() == kMap) {
    clear_has_kind();
    auto* temp = _impl_.kind_.map_;
    _impl_.kind_.map_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_map(::substrait::DerivationExpression_ExpressionMap* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_map();
    _impl_.kind_.map_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.map)
}
inline ::substrait::DerivationExpression_ExpressionMap* DerivationExpression::_internal_mutable_map() {
  if (kind_case() != kMap) {
    clear_kind();
    set_has_map();
    _impl_.kind_.map_ = CreateMaybeMessage<::substrait::DerivationExpression_ExpressionMap>(GetArena());
  }
  return _impl_.kind_.map_;
}
inline ::substrait::DerivationExpression_ExpressionMap* DerivationExpression::mutable_map() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression_ExpressionMap* _msg = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.map)
  return _msg;
}

// .substrait.DerivationExpression.ExpressionUserDefined user_defined = 30 [json_name = "userDefined"];
inline bool DerivationExpression::has_user_defined() const {
  return kind_case() == kUserDefined;
}
inline bool DerivationExpression::_internal_has_user_defined() const {
  return kind_case() == kUserDefined;
}
inline void DerivationExpression::set_has_user_defined() {
  _impl_._oneof_case_[0] = kUserDefined;
}
inline void DerivationExpression::clear_user_defined() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kUserDefined) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.user_defined_;
    }
    clear_has_kind();
  }
}
inline ::substrait::DerivationExpression_ExpressionUserDefined* DerivationExpression::release_user_defined() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.user_defined)
  if (kind_case() == kUserDefined) {
    clear_has_kind();
    auto* temp = _impl_.kind_.user_defined_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.user_defined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::DerivationExpression_ExpressionUserDefined& DerivationExpression::_internal_user_defined() const {
  return kind_case() == kUserDefined ? *_impl_.kind_.user_defined_ : reinterpret_cast<::substrait::DerivationExpression_ExpressionUserDefined&>(::substrait::_DerivationExpression_ExpressionUserDefined_default_instance_);
}
inline const ::substrait::DerivationExpression_ExpressionUserDefined& DerivationExpression::user_defined() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.user_defined)
  return _internal_user_defined();
}
inline ::substrait::DerivationExpression_ExpressionUserDefined* DerivationExpression::unsafe_arena_release_user_defined() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.user_defined)
  if (kind_case() == kUserDefined) {
    clear_has_kind();
    auto* temp = _impl_.kind_.user_defined_;
    _impl_.kind_.user_defined_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_user_defined(::substrait::DerivationExpression_ExpressionUserDefined* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_user_defined();
    _impl_.kind_.user_defined_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.user_defined)
}
inline ::substrait::DerivationExpression_ExpressionUserDefined* DerivationExpression::_internal_mutable_user_defined() {
  if (kind_case() != kUserDefined) {
    clear_kind();
    set_has_user_defined();
    _impl_.kind_.user_defined_ = CreateMaybeMessage<::substrait::DerivationExpression_ExpressionUserDefined>(GetArena());
  }
  return _impl_.kind_.user_defined_;
}
inline ::substrait::DerivationExpression_ExpressionUserDefined* DerivationExpression::mutable_user_defined() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression_ExpressionUserDefined* _msg = _internal_mutable_user_defined();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.user_defined)
  return _msg;
}

// uint32 user_defined_pointer = 31 [json_name = "userDefinedPointer", deprecated = true];
inline bool DerivationExpression::has_user_defined_pointer() const {
  return kind_case() == kUserDefinedPointer;
}
inline void DerivationExpression::set_has_user_defined_pointer() {
  _impl_._oneof_case_[0] = kUserDefinedPointer;
}
inline void DerivationExpression::clear_user_defined_pointer() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kUserDefinedPointer) {
    _impl_.kind_.user_defined_pointer_ = 0u;
    clear_has_kind();
  }
}
inline ::uint32_t DerivationExpression::user_defined_pointer() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.user_defined_pointer)
  return _internal_user_defined_pointer();
}
inline void DerivationExpression::set_user_defined_pointer(::uint32_t value) {
  _internal_set_user_defined_pointer(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.user_defined_pointer)
}
inline ::uint32_t DerivationExpression::_internal_user_defined_pointer() const {
  if (kind_case() == kUserDefinedPointer) {
    return _impl_.kind_.user_defined_pointer_;
  }
  return 0u;
}
inline void DerivationExpression::_internal_set_user_defined_pointer(::uint32_t value) {
  if (kind_case() != kUserDefinedPointer) {
    clear_kind();
    set_has_user_defined_pointer();
  }
  _impl_.kind_.user_defined_pointer_ = value;
}

// string type_parameter_name = 33 [json_name = "typeParameterName"];
inline bool DerivationExpression::has_type_parameter_name() const {
  return kind_case() == kTypeParameterName;
}
inline void DerivationExpression::set_has_type_parameter_name() {
  _impl_._oneof_case_[0] = kTypeParameterName;
}
inline void DerivationExpression::clear_type_parameter_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kTypeParameterName) {
    _impl_.kind_.type_parameter_name_.Destroy();
    clear_has_kind();
  }
}
inline const std::string& DerivationExpression::type_parameter_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.type_parameter_name)
  return _internal_type_parameter_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivationExpression::set_type_parameter_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() != kTypeParameterName) {
    clear_kind();

    set_has_type_parameter_name();
    _impl_.kind_.type_parameter_name_.InitDefault();
  }
  _impl_.kind_.type_parameter_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.type_parameter_name)
}
inline std::string* DerivationExpression::mutable_type_parameter_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_type_parameter_name();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.type_parameter_name)
  return _s;
}
inline const std::string& DerivationExpression::_internal_type_parameter_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (kind_case() != kTypeParameterName) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.kind_.type_parameter_name_.Get();
}
inline void DerivationExpression::_internal_set_type_parameter_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() != kTypeParameterName) {
    clear_kind();

    set_has_type_parameter_name();
    _impl_.kind_.type_parameter_name_.InitDefault();
  }
  _impl_.kind_.type_parameter_name_.Set(value, GetArena());
}
inline std::string* DerivationExpression::_internal_mutable_type_parameter_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() != kTypeParameterName) {
    clear_kind();

    set_has_type_parameter_name();
    _impl_.kind_.type_parameter_name_.InitDefault();
  }
  return _impl_.kind_.type_parameter_name_.Mutable( GetArena());
}
inline std::string* DerivationExpression::release_type_parameter_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.type_parameter_name)
  if (kind_case() != kTypeParameterName) {
    return nullptr;
  }
  clear_has_kind();
  return _impl_.kind_.type_parameter_name_.Release();
}
inline void DerivationExpression::set_allocated_type_parameter_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_kind()) {
    clear_kind();
  }
  if (value != nullptr) {
    set_has_type_parameter_name();
    _impl_.kind_.type_parameter_name_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.type_parameter_name)
}

// string integer_parameter_name = 34 [json_name = "integerParameterName"];
inline bool DerivationExpression::has_integer_parameter_name() const {
  return kind_case() == kIntegerParameterName;
}
inline void DerivationExpression::set_has_integer_parameter_name() {
  _impl_._oneof_case_[0] = kIntegerParameterName;
}
inline void DerivationExpression::clear_integer_parameter_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kIntegerParameterName) {
    _impl_.kind_.integer_parameter_name_.Destroy();
    clear_has_kind();
  }
}
inline const std::string& DerivationExpression::integer_parameter_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.integer_parameter_name)
  return _internal_integer_parameter_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DerivationExpression::set_integer_parameter_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() != kIntegerParameterName) {
    clear_kind();

    set_has_integer_parameter_name();
    _impl_.kind_.integer_parameter_name_.InitDefault();
  }
  _impl_.kind_.integer_parameter_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.integer_parameter_name)
}
inline std::string* DerivationExpression::mutable_integer_parameter_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_integer_parameter_name();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.integer_parameter_name)
  return _s;
}
inline const std::string& DerivationExpression::_internal_integer_parameter_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (kind_case() != kIntegerParameterName) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.kind_.integer_parameter_name_.Get();
}
inline void DerivationExpression::_internal_set_integer_parameter_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() != kIntegerParameterName) {
    clear_kind();

    set_has_integer_parameter_name();
    _impl_.kind_.integer_parameter_name_.InitDefault();
  }
  _impl_.kind_.integer_parameter_name_.Set(value, GetArena());
}
inline std::string* DerivationExpression::_internal_mutable_integer_parameter_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() != kIntegerParameterName) {
    clear_kind();

    set_has_integer_parameter_name();
    _impl_.kind_.integer_parameter_name_.InitDefault();
  }
  return _impl_.kind_.integer_parameter_name_.Mutable( GetArena());
}
inline std::string* DerivationExpression::release_integer_parameter_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.integer_parameter_name)
  if (kind_case() != kIntegerParameterName) {
    return nullptr;
  }
  clear_has_kind();
  return _impl_.kind_.integer_parameter_name_.Release();
}
inline void DerivationExpression::set_allocated_integer_parameter_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_kind()) {
    clear_kind();
  }
  if (value != nullptr) {
    set_has_integer_parameter_name();
    _impl_.kind_.integer_parameter_name_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:substrait.DerivationExpression.integer_parameter_name)
}

// int32 integer_literal = 35 [json_name = "integerLiteral"];
inline bool DerivationExpression::has_integer_literal() const {
  return kind_case() == kIntegerLiteral;
}
inline void DerivationExpression::set_has_integer_literal() {
  _impl_._oneof_case_[0] = kIntegerLiteral;
}
inline void DerivationExpression::clear_integer_literal() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kIntegerLiteral) {
    _impl_.kind_.integer_literal_ = 0;
    clear_has_kind();
  }
}
inline ::int32_t DerivationExpression::integer_literal() const {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.integer_literal)
  return _internal_integer_literal();
}
inline void DerivationExpression::set_integer_literal(::int32_t value) {
  _internal_set_integer_literal(value);
  // @@protoc_insertion_point(field_set:substrait.DerivationExpression.integer_literal)
}
inline ::int32_t DerivationExpression::_internal_integer_literal() const {
  if (kind_case() == kIntegerLiteral) {
    return _impl_.kind_.integer_literal_;
  }
  return 0;
}
inline void DerivationExpression::_internal_set_integer_literal(::int32_t value) {
  if (kind_case() != kIntegerLiteral) {
    clear_kind();
    set_has_integer_literal();
  }
  _impl_.kind_.integer_literal_ = value;
}

// .substrait.DerivationExpression.UnaryOp unary_op = 36 [json_name = "unaryOp"];
inline bool DerivationExpression::has_unary_op() const {
  return kind_case() == kUnaryOp;
}
inline bool DerivationExpression::_internal_has_unary_op() const {
  return kind_case() == kUnaryOp;
}
inline void DerivationExpression::set_has_unary_op() {
  _impl_._oneof_case_[0] = kUnaryOp;
}
inline void DerivationExpression::clear_unary_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kUnaryOp) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.unary_op_;
    }
    clear_has_kind();
  }
}
inline ::substrait::DerivationExpression_UnaryOp* DerivationExpression::release_unary_op() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.unary_op)
  if (kind_case() == kUnaryOp) {
    clear_has_kind();
    auto* temp = _impl_.kind_.unary_op_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.unary_op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::DerivationExpression_UnaryOp& DerivationExpression::_internal_unary_op() const {
  return kind_case() == kUnaryOp ? *_impl_.kind_.unary_op_ : reinterpret_cast<::substrait::DerivationExpression_UnaryOp&>(::substrait::_DerivationExpression_UnaryOp_default_instance_);
}
inline const ::substrait::DerivationExpression_UnaryOp& DerivationExpression::unary_op() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.unary_op)
  return _internal_unary_op();
}
inline ::substrait::DerivationExpression_UnaryOp* DerivationExpression::unsafe_arena_release_unary_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.unary_op)
  if (kind_case() == kUnaryOp) {
    clear_has_kind();
    auto* temp = _impl_.kind_.unary_op_;
    _impl_.kind_.unary_op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_unary_op(::substrait::DerivationExpression_UnaryOp* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_unary_op();
    _impl_.kind_.unary_op_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.unary_op)
}
inline ::substrait::DerivationExpression_UnaryOp* DerivationExpression::_internal_mutable_unary_op() {
  if (kind_case() != kUnaryOp) {
    clear_kind();
    set_has_unary_op();
    _impl_.kind_.unary_op_ = CreateMaybeMessage<::substrait::DerivationExpression_UnaryOp>(GetArena());
  }
  return _impl_.kind_.unary_op_;
}
inline ::substrait::DerivationExpression_UnaryOp* DerivationExpression::mutable_unary_op() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression_UnaryOp* _msg = _internal_mutable_unary_op();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.unary_op)
  return _msg;
}

// .substrait.DerivationExpression.BinaryOp binary_op = 37 [json_name = "binaryOp"];
inline bool DerivationExpression::has_binary_op() const {
  return kind_case() == kBinaryOp;
}
inline bool DerivationExpression::_internal_has_binary_op() const {
  return kind_case() == kBinaryOp;
}
inline void DerivationExpression::set_has_binary_op() {
  _impl_._oneof_case_[0] = kBinaryOp;
}
inline void DerivationExpression::clear_binary_op() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kBinaryOp) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.binary_op_;
    }
    clear_has_kind();
  }
}
inline ::substrait::DerivationExpression_BinaryOp* DerivationExpression::release_binary_op() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.binary_op)
  if (kind_case() == kBinaryOp) {
    clear_has_kind();
    auto* temp = _impl_.kind_.binary_op_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.binary_op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::DerivationExpression_BinaryOp& DerivationExpression::_internal_binary_op() const {
  return kind_case() == kBinaryOp ? *_impl_.kind_.binary_op_ : reinterpret_cast<::substrait::DerivationExpression_BinaryOp&>(::substrait::_DerivationExpression_BinaryOp_default_instance_);
}
inline const ::substrait::DerivationExpression_BinaryOp& DerivationExpression::binary_op() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.binary_op)
  return _internal_binary_op();
}
inline ::substrait::DerivationExpression_BinaryOp* DerivationExpression::unsafe_arena_release_binary_op() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.binary_op)
  if (kind_case() == kBinaryOp) {
    clear_has_kind();
    auto* temp = _impl_.kind_.binary_op_;
    _impl_.kind_.binary_op_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_binary_op(::substrait::DerivationExpression_BinaryOp* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_binary_op();
    _impl_.kind_.binary_op_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.binary_op)
}
inline ::substrait::DerivationExpression_BinaryOp* DerivationExpression::_internal_mutable_binary_op() {
  if (kind_case() != kBinaryOp) {
    clear_kind();
    set_has_binary_op();
    _impl_.kind_.binary_op_ = CreateMaybeMessage<::substrait::DerivationExpression_BinaryOp>(GetArena());
  }
  return _impl_.kind_.binary_op_;
}
inline ::substrait::DerivationExpression_BinaryOp* DerivationExpression::mutable_binary_op() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression_BinaryOp* _msg = _internal_mutable_binary_op();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.binary_op)
  return _msg;
}

// .substrait.DerivationExpression.IfElse if_else = 38 [json_name = "ifElse"];
inline bool DerivationExpression::has_if_else() const {
  return kind_case() == kIfElse;
}
inline bool DerivationExpression::_internal_has_if_else() const {
  return kind_case() == kIfElse;
}
inline void DerivationExpression::set_has_if_else() {
  _impl_._oneof_case_[0] = kIfElse;
}
inline void DerivationExpression::clear_if_else() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kIfElse) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.if_else_;
    }
    clear_has_kind();
  }
}
inline ::substrait::DerivationExpression_IfElse* DerivationExpression::release_if_else() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.if_else)
  if (kind_case() == kIfElse) {
    clear_has_kind();
    auto* temp = _impl_.kind_.if_else_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.if_else_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::DerivationExpression_IfElse& DerivationExpression::_internal_if_else() const {
  return kind_case() == kIfElse ? *_impl_.kind_.if_else_ : reinterpret_cast<::substrait::DerivationExpression_IfElse&>(::substrait::_DerivationExpression_IfElse_default_instance_);
}
inline const ::substrait::DerivationExpression_IfElse& DerivationExpression::if_else() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.if_else)
  return _internal_if_else();
}
inline ::substrait::DerivationExpression_IfElse* DerivationExpression::unsafe_arena_release_if_else() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.if_else)
  if (kind_case() == kIfElse) {
    clear_has_kind();
    auto* temp = _impl_.kind_.if_else_;
    _impl_.kind_.if_else_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_if_else(::substrait::DerivationExpression_IfElse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_if_else();
    _impl_.kind_.if_else_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.if_else)
}
inline ::substrait::DerivationExpression_IfElse* DerivationExpression::_internal_mutable_if_else() {
  if (kind_case() != kIfElse) {
    clear_kind();
    set_has_if_else();
    _impl_.kind_.if_else_ = CreateMaybeMessage<::substrait::DerivationExpression_IfElse>(GetArena());
  }
  return _impl_.kind_.if_else_;
}
inline ::substrait::DerivationExpression_IfElse* DerivationExpression::mutable_if_else() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression_IfElse* _msg = _internal_mutable_if_else();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.if_else)
  return _msg;
}

// .substrait.DerivationExpression.ReturnProgram return_program = 39 [json_name = "returnProgram"];
inline bool DerivationExpression::has_return_program() const {
  return kind_case() == kReturnProgram;
}
inline bool DerivationExpression::_internal_has_return_program() const {
  return kind_case() == kReturnProgram;
}
inline void DerivationExpression::set_has_return_program() {
  _impl_._oneof_case_[0] = kReturnProgram;
}
inline void DerivationExpression::clear_return_program() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (kind_case() == kReturnProgram) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.return_program_;
    }
    clear_has_kind();
  }
}
inline ::substrait::DerivationExpression_ReturnProgram* DerivationExpression::release_return_program() {
  // @@protoc_insertion_point(field_release:substrait.DerivationExpression.return_program)
  if (kind_case() == kReturnProgram) {
    clear_has_kind();
    auto* temp = _impl_.kind_.return_program_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.return_program_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::substrait::DerivationExpression_ReturnProgram& DerivationExpression::_internal_return_program() const {
  return kind_case() == kReturnProgram ? *_impl_.kind_.return_program_ : reinterpret_cast<::substrait::DerivationExpression_ReturnProgram&>(::substrait::_DerivationExpression_ReturnProgram_default_instance_);
}
inline const ::substrait::DerivationExpression_ReturnProgram& DerivationExpression::return_program() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:substrait.DerivationExpression.return_program)
  return _internal_return_program();
}
inline ::substrait::DerivationExpression_ReturnProgram* DerivationExpression::unsafe_arena_release_return_program() {
  // @@protoc_insertion_point(field_unsafe_arena_release:substrait.DerivationExpression.return_program)
  if (kind_case() == kReturnProgram) {
    clear_has_kind();
    auto* temp = _impl_.kind_.return_program_;
    _impl_.kind_.return_program_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DerivationExpression::unsafe_arena_set_allocated_return_program(::substrait::DerivationExpression_ReturnProgram* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_return_program();
    _impl_.kind_.return_program_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:substrait.DerivationExpression.return_program)
}
inline ::substrait::DerivationExpression_ReturnProgram* DerivationExpression::_internal_mutable_return_program() {
  if (kind_case() != kReturnProgram) {
    clear_kind();
    set_has_return_program();
    _impl_.kind_.return_program_ = CreateMaybeMessage<::substrait::DerivationExpression_ReturnProgram>(GetArena());
  }
  return _impl_.kind_.return_program_;
}
inline ::substrait::DerivationExpression_ReturnProgram* DerivationExpression::mutable_return_program() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::substrait::DerivationExpression_ReturnProgram* _msg = _internal_mutable_return_program();
  // @@protoc_insertion_point(field_mutable:substrait.DerivationExpression.return_program)
  return _msg;
}

inline bool DerivationExpression::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void DerivationExpression::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline DerivationExpression::KindCase DerivationExpression::kind_case() const {
  return DerivationExpression::KindCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace substrait


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::substrait::DerivationExpression_UnaryOp_UnaryOpType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::DerivationExpression_UnaryOp_UnaryOpType>() {
  return ::substrait::DerivationExpression_UnaryOp_UnaryOpType_descriptor();
}
template <>
struct is_proto_enum<::substrait::DerivationExpression_BinaryOp_BinaryOpType> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::substrait::DerivationExpression_BinaryOp_BinaryOpType>() {
  return ::substrait::DerivationExpression_BinaryOp_BinaryOpType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_substrait_2ftype_5fexpressions_2eproto_2epb_2eh
